import torch
import numpy as np
from typing import Tuple, List, Optional
import time


class TorchGeneticAlgorithm:
    """
    Algoritmo Gen√©tico completamente vectorizado en PyTorch.
    Todas las operaciones se ejecutan en GPU.
    """
    
    def __init__(
        self,
        n_items: int,
        allowed_angles: List[float],
        place_func,  # Funci√≥n que acepta batches: (B, n_items), (B, n_items)
        fitness_func,  # Funci√≥n que acepta batches: (B, n_items), (B, n_items) -> (B,)
        population_size: int = 100,
        device: str = 'cuda' if torch.cuda.is_available() else 'cpu',
        dtype: torch.dtype = torch.float32
    ):
        self.n_items = n_items
        self.allowed_angles = torch.tensor(allowed_angles, device=device, dtype=dtype)
        self.n_angles = len(allowed_angles)
        self.place_func = place_func
        self.fitness_func = fitness_func
        self.population_size = population_size
        self.device = device
        self.dtype = dtype
        
        print(f"üöÄ Inicializando GA en: {device}")
        if device == 'cuda':
            print(f"   GPU: {torch.cuda.get_device_name(0)}")
            print(f"   Memoria disponible: {torch.cuda.get_device_properties(0).total_memory / 1e9:.2f} GB")
    
    def initialize_population(self) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Inicializa poblaci√≥n de forma vectorizada.
        
        Returns:
            indices: (population_size, n_items) - permutaciones
            angles: (population_size, n_items) - √≠ndices de √°ngulos permitidos
        """
        # Generar permutaciones aleatorias
        indices = torch.stack([
            torch.randperm(self.n_items, device=self.device)
            for _ in range(self.population_size)
        ])
        
        # Generar √°ngulos aleatorios (√≠ndices en allowed_angles)
        angles_idx = torch.randint(
            0, self.n_angles, 
            (self.population_size, self.n_items),
            device=self.device
        )
        
        return indices, angles_idx
    
    def angles_idx_to_values(self, angles_idx: torch.Tensor) -> torch.Tensor:
        """Convierte √≠ndices de √°ngulos a valores reales"""
        return self.allowed_angles[angles_idx]
    
    def evaluate_population(
        self, 
        indices: torch.Tensor, 
        angles_idx: torch.Tensor
    ) -> torch.Tensor:
        """
        Eval√∫a toda la poblaci√≥n en paralelo.
        
        Args:
            indices: (population_size, n_items)
            angles_idx: (population_size, n_items)
        
        Returns:
            fitness: (population_size,)
        """
        # Convertir √≠ndices de √°ngulos a valores
        angles = self.angles_idx_to_values(angles_idx)
        
        # Evaluar en batch (ESTO ES LA CLAVE)
        fitness = self.fitness_func(indices, angles)
        
        return fitness
    
    def tournament_selection(
        self,
        indices: torch.Tensor,
        angles_idx: torch.Tensor,
        fitness: torch.Tensor,
        tournament_size: int = 5,
        n_parents: int = None
    ) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Selecci√≥n por torneo vectorizada.
        """
        if n_parents is None:
            n_parents = self.population_size
        
        # Generar torneos aleatorios: (n_parents, tournament_size)
        tournament_indices = torch.randint(
            0, self.population_size,
            (n_parents, tournament_size),
            device=self.device
        )
        
        # Obtener fitness de cada competidor: (n_parents, tournament_size)
        tournament_fitness = fitness[tournament_indices]
        
        # Encontrar ganadores (√≠ndice dentro del torneo)
        winners_in_tournament = torch.argmin(tournament_fitness, dim=1)
        
        # Mapear a √≠ndices absolutos en poblaci√≥n
        winner_indices = tournament_indices[
            torch.arange(n_parents, device=self.device), 
            winners_in_tournament
        ]
        
        # Retornar padres seleccionados
        return indices[winner_indices], angles_idx[winner_indices]
    
    def crossover_ox_vectorized(
        self,
        parent1_indices: torch.Tensor,
        parent2_indices: torch.Tensor,
        crossover_rate: float = 0.8
    ) -> torch.Tensor:
        """
        Order Crossover (OX) vectorizado para m√∫ltiples pares.
        
        Args:
            parent1_indices: (n_pairs, n_items)
            parent2_indices: (n_pairs, n_items)
        
        Returns:
            children: (n_pairs, n_items)
        """
        n_pairs = parent1_indices.shape[0]
        
        # M√°scara de crossover
        do_crossover = torch.rand(n_pairs, device=self.device) < crossover_rate
        
        # Generar puntos de corte aleatorios para cada par
        cut_points = torch.sort(
            torch.randint(0, self.n_items, (n_pairs, 2), device=self.device),
            dim=1
        )[0]
        
        children = torch.zeros_like(parent1_indices)
        
        for i in range(n_pairs):
            if do_crossover[i]:
                # Order Crossover para el par i
                start, end = cut_points[i]
                
                child = torch.full((self.n_items,), -1, device=self.device)
                child[start:end] = parent1_indices[i, start:end]
                
                # Llenar con elementos de parent2 que no est√°n
                mask = torch.isin(parent2_indices[i], child[start:end], invert=True)
                remaining = parent2_indices[i][mask]
                
                # Llenar posiciones vac√≠as
                empty_positions = (child == -1).nonzero(as_tuple=True)[0]
                child[empty_positions] = remaining[:len(empty_positions)]
                
                children[i] = child
            else:
                children[i] = parent1_indices[i]
        
        return children
    
    def crossover_angles_uniform(
        self,
        parent1_angles: torch.Tensor,
        parent2_angles: torch.Tensor,
        crossover_rate: float = 0.8
    ) -> torch.Tensor:
        """
        Crossover uniforme para √°ngulos (vectorizado).
        
        Args:
            parent1_angles: (n_pairs, n_items)
            parent2_angles: (n_pairs, n_items)
        
        Returns:
            children: (n_pairs, n_items)
        """
        n_pairs = parent1_angles.shape[0]
        
        # M√°scara aleatoria para seleccionar de cada padre
        mask = torch.rand(n_pairs, self.n_items, device=self.device) < 0.5
        
        children = torch.where(mask, parent1_angles, parent2_angles)
        
        return children
    
    def mutate_indices_vectorized(
        self,
        indices: torch.Tensor,
        mutation_rate: float = 0.3
    ) -> torch.Tensor:
        """
        Mutaci√≥n de √≠ndices vectorizada (swap).
        
        Args:
            indices: (batch_size, n_items)
        
        Returns:
            mutated: (batch_size, n_items)
        """
        batch_size = indices.shape[0]
        mutated = indices.clone()
        
        # Determinar qu√© individuos mutan
        mutate_mask = torch.rand(batch_size, device=self.device) < mutation_rate
        n_mutate = mutate_mask.sum().item()
        
        if n_mutate > 0:
            # Para cada individuo que muta, hacer swap
            for i in torch.where(mutate_mask)[0]:
                # Swap de 1-3 pares aleatorios
                n_swaps = torch.randint(1, 4, (1,), device=self.device).item()
                
                for _ in range(n_swaps):
                    idx1, idx2 = torch.randperm(self.n_items, device=self.device)[:2]
                    mutated[i, idx1], mutated[i, idx2] = mutated[i, idx2].clone(), mutated[i, idx1].clone()
        
        return mutated
    
    def mutate_angles_vectorized(
        self,
        angles_idx: torch.Tensor,
        mutation_rate: float = 0.4
    ) -> torch.Tensor:
        """
        Mutaci√≥n de √°ngulos vectorizada.
        
        Args:
            angles_idx: (batch_size, n_items) - √≠ndices en allowed_angles
        
        Returns:
            mutated: (batch_size, n_items)
        """
        # M√°scara de mutaci√≥n: (batch_size, n_items)
        mutate_mask = torch.rand_like(angles_idx, dtype=torch.float32) < mutation_rate
        
        # Nuevos √°ngulos aleatorios
        new_angles = torch.randint(
            0, self.n_angles,
            angles_idx.shape,
            device=self.device
        )
        
        # Aplicar mutaci√≥n solo donde la m√°scara es True
        mutated = torch.where(mutate_mask, new_angles, angles_idx)
        
        return mutated
    
    def evolve(
        self,
        n_generations: int = 300,
        elite_size: int = 10,
        mutation_rate_indices: float = 0.3,
        mutation_rate_angles: float = 0.4,
        crossover_rate: float = 0.8,
        tournament_size: int = 5,
        early_stopping_patience: int = 50,
        verbose: bool = True
    ) -> Tuple[torch.Tensor, torch.Tensor, float, List[float]]:
        """
        Ejecuta el algoritmo gen√©tico completo en GPU.
        
        Returns:
            best_indices: (n_items,)
            best_angles_idx: (n_items,)
            best_fitness: float
            history: List[float]
        """
        # Inicializar poblaci√≥n
        if verbose:
            print(f"\n{'='*70}")
            print("Inicializando poblaci√≥n...")
        
        indices = torch.zeros((self.population_size, self.n_items), 
                             dtype=torch.long, device=self.device)
        angles_idx = torch.zeros((self.population_size, self.n_items),
                                dtype=torch.long, device=self.device)
        
        # Inicializaci√≥n en CPU y luego mover a GPU (m√°s eficiente)
        for i in range(self.population_size):
            indices[i] = torch.randperm(self.n_items, device=self.device)
            angles_idx[i] = torch.randint(0, self.n_angles, (self.n_items,), device=self.device)
        
        # Evaluar poblaci√≥n inicial
        if verbose:
            print("Evaluando poblaci√≥n inicial...")
            start_time = time.time()
        
        fitness = self.evaluate_population(indices, angles_idx)
        
        if verbose:
            eval_time = time.time() - start_time
            print(f"‚úì Poblaci√≥n evaluada en {eval_time:.3f}s")
            print(f"  ({self.population_size/eval_time:.1f} evaluaciones/segundo)")
        
        # Tracking
        best_fitness_history = []
        best_idx = torch.argmin(fitness)
        global_best_fitness = fitness[best_idx].item()
        global_best_indices = indices[best_idx].clone()
        global_best_angles_idx = angles_idx[best_idx].clone()
        
        no_improvement = 0
        
        if verbose:
            print(f"Fitness inicial mejor: {global_best_fitness:.6f}")
            print(f"\n{'='*70}")
            print("Iniciando evoluci√≥n...")
            print(f"{'='*70}\n")
        
        # Ciclo evolutivo
        for generation in range(n_generations):
            gen_start = time.time()
            
            # 1. ELITISMO
            elite_indices_sorted = torch.argsort(fitness)[:elite_size]
            elite_indices_pop = indices[elite_indices_sorted].clone()
            elite_angles_pop = angles_idx[elite_indices_sorted].clone()
            
            # 2. SELECCI√ìN
            n_offspring = self.population_size - elite_size
            parent1_indices, parent1_angles = self.tournament_selection(
                indices, angles_idx, fitness, tournament_size, n_offspring
            )
            parent2_indices, parent2_angles = self.tournament_selection(
                indices, angles_idx, fitness, tournament_size, n_offspring
            )
            
            # 3. CROSSOVER
            # Para OX necesitamos procesar por pares (no completamente vectorizable)
            offspring_indices = self.crossover_ox_vectorized(
                parent1_indices, parent2_indices, crossover_rate
            )
            
            # Crossover de √°ngulos (completamente vectorizado)
            offspring_angles = self.crossover_angles_uniform(
                parent1_angles, parent2_angles, crossover_rate
            )
            
            # 4. MUTACI√ìN
            offspring_indices = self.mutate_indices_vectorized(
                offspring_indices, mutation_rate_indices
            )
            offspring_angles = self.mutate_angles_vectorized(
                offspring_angles, mutation_rate_angles
            )
            
            # 5. REEMPLAZO
            indices = torch.cat([elite_indices_pop, offspring_indices], dim=0)
            angles_idx = torch.cat([elite_angles_pop, offspring_angles], dim=0)
            
            # 6. EVALUACI√ìN
            fitness = self.evaluate_population(indices, angles_idx)
            
            # 7. ACTUALIZAR MEJOR
            current_best_idx = torch.argmin(fitness)
            current_best_fitness = fitness[current_best_idx].item()
            best_fitness_history.append(current_best_fitness)
            
            if current_best_fitness < global_best_fitness:
                global_best_fitness = current_best_fitness
                global_best_indices = indices[current_best_idx].clone()
                global_best_angles_idx = angles_idx[current_best_idx].clone()
                no_improvement = 0
                
                if verbose:
                    print(f"Gen {generation:4d}: ‚òÖ NUEVA MEJOR = {global_best_fitness:.6f}")
            else:
                no_improvement += 1
            
            # 8. EARLY STOPPING
            if no_improvement >= early_stopping_patience:
                if verbose:
                    print(f"\n{'='*70}")
                    print(f"Early stopping en generaci√≥n {generation}")
                    print(f"Sin mejora por {early_stopping_patience} generaciones")
                break
            
            # 9. LOGGING
            gen_time = time.time() - gen_start
            if verbose and generation % 50 == 0 and generation > 0:
                avg_fitness = fitness.mean().item()
                print(f"Gen {generation:4d}: Mejor={current_best_fitness:.6f}, "
                      f"Promedio={avg_fitness:.6f}, Tiempo={gen_time:.3f}s")
        
        if verbose:
            print(f"\n{'='*70}")
            print("RESULTADOS FINALES")
            print(f"{'='*70}")
            print(f"Mejor fitness: {global_best_fitness:.6f}")
            print(f"Generaciones: {len(best_fitness_history)}")
            print(f"{'='*70}\n")
        
        return (
            global_best_indices.cpu(),
            global_best_angles_idx.cpu(),
            global_best_fitness,
            best_fitness_history
        )


# ============================================================================
# EJEMPLO DE USO CON PYTORCH
# ============================================================================

def example_fitness_batch_torch(indices: torch.Tensor, angles: torch.Tensor) -> torch.Tensor:
    """
    Funci√≥n fitness que opera en batches.
    
    Args:
        indices: (batch_size, n_items) - permutaciones
        angles: (batch_size, n_items) - √°ngulos en grados
    
    Returns:
        fitness: (batch_size,) - fitness de cada individuo
    """
    batch_size, n_items = indices.shape
    device = indices.device
    
    # Objetivo: indices invertidos y √°ngulos alternando 90/180
    indices_ideal = torch.arange(n_items - 1, -1, -1, device=device).unsqueeze(0).expand(batch_size, -1)
    
    angles_ideal = torch.tensor(
        [90.0 if i % 2 == 0 else 180.0 for i in range(n_items)],
        device=device
    ).unsqueeze(0).expand(batch_size, -1)
    
    # Calcular distancias (vectorizado para todo el batch)
    dist_indices = torch.norm(indices.float() - indices_ideal.float(), dim=1)
    dist_angles = torch.norm(angles - angles_ideal, dim=1)
    
    fitness = dist_indices + dist_angles
    
    return fitness


def example_place_batch_torch(indices: torch.Tensor, angles: torch.Tensor):
    """
    Funci√≥n de colocaci√≥n (placeholder).
    En tu caso real, esto ejecutar√≠a tu simulaci√≥n/renderizado en batch.
    """
    # Aqu√≠ ir√≠a tu l√≥gica de placement en batch
    # Por ahora, siempre retorna v√°lido
    return torch.ones(indices.shape[0], dtype=torch.bool, device=indices.device)


if __name__ == "__main__":
    
    # Configuraci√≥n
    n_items = 15
    allowed_angles = [0.0, 90.0, 180.0, 270.0]
    population_size = 200  # Puedes usar poblaciones m√°s grandes en GPU!
    
    print("\n" + "="*70)
    print("ALGORITMO GEN√âTICO VECTORIZADO EN PYTORCH")
    print("="*70)
    print(f"Items: {n_items}")
    print(f"√Ångulos permitidos: {allowed_angles}")
    print(f"Poblaci√≥n: {population_size}")
    print(f"Device: {'cuda' if torch.cuda.is_available() else 'cpu'}")
    print("="*70)
    
    # Crear algoritmo
    ga = TorchGeneticAlgorithm(
        n_items=n_items,
        allowed_angles=allowed_angles,
        place_func=example_place_batch_torch,
        fitness_func=example_fitness_batch_torch,
        population_size=population_size,
        device='cuda' if torch.cuda.is_available() else 'cpu'
    )
    
    # Ejecutar
    start_time = time.time()
    
    best_indices, best_angles_idx, best_fitness, history = ga.evolve(
        n_generations=300,
        elite_size=20,
        mutation_rate_indices=0.3,
        mutation_rate_angles=0.4,
        crossover_rate=0.8,
        tournament_size=5,
        early_stopping_patience=60,
        verbose=True
    )
    
    total_time = time.time() - start_time
    
    # Convertir resultados
    best_angles = ga.allowed_angles[best_angles_idx.to(ga.device)].cpu().numpy()
    best_indices = best_indices.numpy()
    
    print(f"\nTiempo total: {total_time:.2f}s")
    print(f"Fitness final: {best_fitness:.6f}")
    print(f"Indices: {best_indices}")
    print(f"√Ångulos: {best_angles}")
    
    # Comparar con objetivo
    optimal_indices = np.array(list(range(n_items))[::-1])
    optimal_angles = np.array([90.0 if i % 2 == 0 else 180.0 for i in range(n_items)])
    
    print(f"\nObjetivo:")
    print(f"Indices: {optimal_indices}")
    print(f"√Ångulos: {optimal_angles}")
    
    if np.array_equal(best_indices, optimal_indices) and np.array_equal(best_angles, optimal_angles):
        print("\n‚úì‚úì‚úì SOLUCI√ìN √ìPTIMA ENCONTRADA! ‚úì‚úì‚úì")
