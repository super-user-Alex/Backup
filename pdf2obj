import fitz  # PyMuPDF
import numpy as np
from collections import defaultdict
from shapely.geometry import Polygon, MultiPolygon, box
from shapely.ops import unary_union
import os

class VectorObjectExtractor:
    def __init__(self, pdf_path, tolerance=2.0):
        """
        Args:
            pdf_path: Ruta al PDF
            tolerance: Distancia máxima para considerar primitivas como conectadas
        """
        self.doc = fitz.open(pdf_path)
        self.tolerance = tolerance
    
    def extract_drawings_from_page(self, page_num=0):
        """Extrae todos los drawings de una página"""
        page = self.doc[page_num]
        drawings = page.get_drawings()
        return page, drawings
    
    def get_drawing_bounds(self, drawing):
        """Calcula el bounding box de un drawing"""
        points = []
        
        for item in drawing.get("items", []):
            if item[0] == "l":  # línea
                points.extend([item[1], item[2]])
            elif item[0] == "c":  # curva bézier
                points.extend([item[1], item[2], item[3], item[4]])
            elif item[0] == "re":  # rectángulo
                # CORRECCIÓN: item[1] es una tupla (x, y, w, h)
                rect_data = item[1]
                x, y, w, h = rect_data.x, rect_data.y, rect_data.width, rect_data.height
                points.extend([
                    fitz.Point(x, y),
                    fitz.Point(x + w, y),
                    fitz.Point(x, y + h),
                    fitz.Point(x + w, y + h)
                ])
        
        if not points:
            return None
        
        xs = [p.x for p in points]
        ys = [p.y for p in points]
        
        return fitz.Rect(min(xs), min(ys), max(xs), max(ys))
    
    def rect_contains_rect(self, outer, inner):
        """
        Verifica si outer contiene completamente a inner
        """
        if not outer or not inner:
            return False
        
        return (outer.x0 <= inner.x0 and 
                outer.y0 <= inner.y0 and
                outer.x1 >= inner.x1 and
                outer.y1 >= inner.y1)
    
    def drawings_are_connected(self, draw1, draw2):
        """
        Determina si dos drawings están conectados espacialmente o uno contiene al otro
        """
        rect1 = self.get_drawing_bounds(draw1)
        rect2 = self.get_drawing_bounds(draw2)
        
        if not rect1 or not rect2:
            return False
        
        # Verificar contención jerárquica
        if self.rect_contains_rect(rect1, rect2) or self.rect_contains_rect(rect2, rect1):
            return True
        
        # Expandir rectángulos con la tolerancia para detectar proximidad
        expanded_rect1 = fitz.Rect(
            rect1.x0 - self.tolerance,
            rect1.y0 - self.tolerance,
            rect1.x1 + self.tolerance,
            rect1.y1 + self.tolerance
        )
        
        # Verificar si los rectángulos expandidos se intersectan
        return expanded_rect1.intersects(rect2)
    
    def is_white_background(self, drawing):
        """
        Detecta si un drawing es parte del fondo blanco
        """
        # Verificar color de relleno
        fill = drawing.get("fill")
        if fill:
            # CMYK: blanco es (0, 0, 0, 0) o muy cercano
            # RGB: blanco es (1, 1, 1) o muy cercano
            if isinstance(fill, (list, tuple)):
                if len(fill) == 4:  # CMYK
                    return all(c < 0.05 for c in fill)
                elif len(fill) == 3:  # RGB
                    return all(c > 0.95 for c in fill)
        
        return False
    
    def group_connected_drawings(self, drawings):
        """
        Agrupa drawings conectados usando un enfoque de Union-Find
        Incluye contención jerárquica
        """
        n = len(drawings)
        parent = list(range(n))
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            px, py = find(x), find(y)
            if px != py:
                parent[px] = py
        
        # Filtrar fondos blancos
        valid_drawings = []
        valid_indices = []
        
        for i, drawing in enumerate(drawings):
            if not self.is_white_background(drawing):
                valid_drawings.append(drawing)
                valid_indices.append(i)
        
        print(f"Drawings válidos (sin fondo blanco): {len(valid_drawings)}")
        
        # Construir grafo de conectividad (incluyendo contención)
        connections = 0
        for i in range(len(valid_drawings)):
            for j in range(i + 1, len(valid_drawings)):
                if self.drawings_are_connected(valid_drawings[i], valid_drawings[j]):
                    union(i, j)
                    connections += 1
        
        print(f"Conexiones detectadas: {connections}")
        
        # Agrupar por componente
        groups = defaultdict(list)
        for i, drawing in enumerate(valid_drawings):
            root = find(i)
            groups[root].append(drawing)
        
        return list(groups.values())
    
    def get_object_contour(self, drawings_group):
        """
        Calcula el contorno exterior de un grupo de drawings
        """
        polygons = []
        
        for drawing in drawings_group:
            rect = self.get_drawing_bounds(drawing)
            if rect:
                poly = box(rect.x0, rect.y0, rect.x1, rect.y1)
                polygons.append(poly)
        
        if not polygons:
            return None
        
        # Unir todos los polígonos
        merged = unary_union(polygons)
        
        # Obtener el contorno exterior
        if isinstance(merged, Polygon):
            return list(merged.exterior.coords)
        elif isinstance(merged, MultiPolygon):
            largest = max(merged.geoms, key=lambda p: p.area)
            return list(largest.exterior.coords)
        
        return None
    
    def get_group_bbox(self, drawings_group):
        """Calcula el bounding box total de un grupo"""
        all_rects = [self.get_drawing_bounds(d) for d in drawings_group]
        all_rects = [r for r in all_rects if r]
        
        if not all_rects:
            return None
        
        bbox = all_rects[0]
        for rect in all_rects[1:]:
            bbox |= rect  # Unión de rectángulos
        
        return bbox
    
    def extract_object_to_pdf(self, page, drawings_group, output_path, margin=5):
        """
        Extrae un grupo de drawings a un PDF individual preservando vectores
        
        Args:
            page: Página fuente de PyMuPDF
            drawings_group: Lista de drawings del grupo
            output_path: Ruta del PDF de salida
            margin: Margen adicional alrededor del objeto (en puntos)
        """
        # Calcular bounding box del grupo
        bbox = self.get_group_bbox(drawings_group)
        
        if not bbox:
            print(f"No se pudo calcular bbox para {output_path}")
            return None
        
        # Añadir margen
        crop_rect = fitz.Rect(
            bbox.x0 - margin,
            bbox.y0 - margin,
            bbox.x1 + margin,
            bbox.y1 + margin
        )
        
        # Asegurar que no salga de los límites de la página
        crop_rect = crop_rect & page.rect
        
        # Crear nuevo documento
        new_doc = fitz.open()
        
        # Crear nueva página con el tamaño del recorte
        new_page = new_doc.new_page(
            width=crop_rect.width,
            height=crop_rect.height
        )
        
        # Estrategia: Copiar la página completa y luego recortar
        # Esto preserva todos los vectores originales
        
        # Insertar la página original
        new_page.show_pdf_page(
            new_page.rect,  # Rectángulo destino
            self.doc,       # Documento fuente
            page.number,    # Número de página fuente
            clip=crop_rect  # Área a copiar
        )
        
        # Ajustar la posición (mover el contenido al origen)
        # Esto se hace moviendo todo el contenido
        matrix = fitz.Matrix(1, 0, 0, 1, -crop_rect.x0, -crop_rect.y0)
        
        # Aplicar transformación al contenido
        # Necesitamos reconstruir la página con el offset
        temp_doc = fitz.open()
        temp_page = temp_doc.new_page(
            width=crop_rect.width,
            height=crop_rect.height
        )
        
        # Mostrar con transformación
        temp_page.show_pdf_page(
            fitz.Rect(0, 0, crop_rect.width, crop_rect.height),
            self.doc,
            page.number,
            clip=crop_rect
        )
        
        # Guardar
        temp_doc.save(output_path)
        temp_doc.close()
        new_doc.close()
        
        print(f"✓ Exportado: {output_path} (bbox: {bbox})")
        return bbox
    
    def visualize_groups(self, page, groups, output_path):
        """
        Crea un PDF visualizando los grupos detectados con colores
        """
        colors = [
            (1, 0, 0),    # Rojo
            (0, 1, 0),    # Verde
            (0, 0, 1),    # Azul
            (1, 1, 0),    # Amarillo
            (1, 0, 1),    # Magenta
            (0, 1, 1),    # Cyan
            (0.5, 0, 0),  # Rojo oscuro
            (0, 0.5, 0),  # Verde oscuro
            (0, 0, 0.5),  # Azul oscuro
        ]
        
        # Crear copia del documento
        temp_doc = fitz.open()
        temp_page = temp_doc.new_page(width=page.rect.width, height=page.rect.height)
        
        # Copiar contenido original
        temp_page.show_pdf_page(temp_page.rect, self.doc, page.number)
        
        # Dibujar cada grupo con un color diferente
        for i, group in enumerate(groups):
            color = colors[i % len(colors)]
            
            # Dibujar bounding boxes de cada drawing
            for drawing in group:
                rect = self.get_drawing_bounds(drawing)
                if rect:
                    temp_page.draw_rect(rect, color=color, width=1.5, fill_opacity=0.1)
            
            # Dibujar bounding box del grupo completo
            group_bbox = self.get_group_bbox(group)
            if group_bbox:
                temp_page.draw_rect(group_bbox, color=color, width=3)
            
            # Dibujar contorno exterior
            contour = self.get_object_contour(group)
            if contour and len(contour) > 2:
                for j in range(len(contour) - 1):
                    p1 = fitz.Point(contour[j][0], contour[j][1])
                    p2 = fitz.Point(contour[j+1][0], contour[j+1][1])
                    temp_page.draw_line(p1, p2, color=color, width=2, dashes="[3 2]")
            
            # Añadir etiqueta con número de objeto
            if group_bbox:
                temp_page.insert_text(
                    fitz.Point(group_bbox.x0 + 5, group_bbox.y0 + 15),
                    f"Obj {i}",
                    fontsize=12,
                    color=color
                )
        
        temp_doc.save(output_path)
        temp_doc.close()
    
    def process_and_export(self, page_num=0, output_dir="extracted_objects"):
        """
        Procesa una página, detecta objetos y exporta cada uno a un PDF individual
        
        Args:
            page_num: Número de página a procesar
            output_dir: Directorio donde guardar los PDFs individuales
        """
        # Crear directorio de salida
        os.makedirs(output_dir, exist_ok=True)
        
        # Extraer drawings
        page, drawings = self.extract_drawings_from_page(page_num)
        
        print(f"\n{'='*60}")
        print(f"Procesando página {page_num}")
        print(f"{'='*60}")
        print(f"Total drawings encontrados: {len(drawings)}")
        
        # Agrupar drawings conectados
        groups = self.group_connected_drawings(drawings)
        
        print(f"\n{'='*60}")
        print(f"✓ Objetos independientes detectados: {len(groups)}")
        print(f"{'='*60}\n")
        
        # Exportar cada grupo
        results = []
        for i, group in enumerate(groups):
            output_path = os.path.join(output_dir, f"objeto_{i:03d}.pdf")
            
            bbox = self.extract_object_to_pdf(page, group, output_path)
            contour = self.get_object_contour(group)
            
            results.append({
                'id': i,
                'drawings': group,
                'contour': contour,
                'bbox': bbox,
                'num_primitives': len(group),
                'output_path': output_path
            })
            
            print(f"  Objeto {i}: {len(group)} primitivas → {output_path}")
        
        # Crear visualización
        viz_path = os.path.join(output_dir, "_visualizacion_grupos.pdf")
        self.visualize_groups(page, [obj['drawings'] for obj in results], viz_path)
        print(f"\n✓ Visualización guardada: {viz_path}")
        
        return page, results


# Ejemplo de uso
if __name__ == "__main__":
    import sys
    
    # Usar argumento de línea de comandos o archivo por defecto
    pdf_path = sys.argv[1] if len(sys.argv) > 1 else "tu_archivo.pdf"
    
    if not os.path.exists(pdf_path):
        print(f"Error: No se encuentra el archivo {pdf_path}")
        sys.exit(1)
    
    print(f"Procesando: {pdf_path}\n")
    
    # Inicializar extractor
    # Ajusta la tolerancia según la separación entre elementos
    extractor = VectorObjectExtractor(pdf_path, tolerance=3.0)
    
    # Procesar y exportar
    page, objects = extractor.process_and_export(
        page_num=0,
        output_dir="objetos_extraidos"
    )
    
    # Resumen final
    print(f"\n{'='*60}")
    print("RESUMEN")
    print(f"{'='*60}")
    print(f"Total de objetos exportados: {len(objects)}")
    
    for obj in objects:
        print(f"\n  Objeto {obj['id']:03d}:")
        print(f"    - Primitivas: {obj['num_primitives']}")
        if obj['bbox']:
            print(f"    - Dimensiones: {obj['bbox'].width:.1f} x {obj['bbox'].height:.1f} pts")
        print(f"    - Archivo: {obj['output_path']}")
    
    print(f"\n✓ Proceso completado")
