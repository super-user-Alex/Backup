#!/usr/bin/env python3
"""
Advanced Vector PDF Masking with True Clipping
Versión avanzada que aplica clipping paths reales al contenido vectorial.
"""

import fitz  # PyMuPDF
from PIL import Image
import numpy as np
from typing import List, Tuple


def load_mask(mask_path: str) -> np.ndarray:
    """Carga y binariza la máscara PNG."""
    img = Image.open(mask_path).convert('L')
    mask_array = np.array(img)
    return mask_array > 128


def create_grid_cells(page_rect: fitz.Rect, grid_divisions: int) -> List[fitz.Rect]:
    """Divide la página en grilla uniforme."""
    cells = []
    cell_width = page_rect.width / grid_divisions
    cell_height = page_rect.height / grid_divisions
    
    for i in range(grid_divisions):
        for j in range(grid_divisions):
            x0 = page_rect.x0 + j * cell_width
            y0 = page_rect.y0 + i * cell_height
            x1 = x0 + cell_width
            y1 = y0 + cell_height
            cells.append(fitz.Rect(x0, y0, x1, y1))
    
    return cells


def is_cell_visible(cell: fitz.Rect, page_rect: fitz.Rect, 
                    mask: np.ndarray, threshold: float = 0.5) -> bool:
    """Determina si una celda debe ser visible según la máscara."""
    mask_height, mask_width = mask.shape
    
    # Mapear coordenadas PDF a máscara
    x0_norm = (cell.x0 - page_rect.x0) / page_rect.width
    y0_norm = (cell.y0 - page_rect.y0) / page_rect.height
    x1_norm = (cell.x1 - page_rect.x0) / page_rect.width
    y1_norm = (cell.y1 - page_rect.y0) / page_rect.height
    
    x0_px = int(x0_norm * mask_width)
    y0_px = int(y0_norm * mask_height)
    x1_px = int(x1_norm * mask_width)
    y1_px = int(y1_norm * mask_height)
    
    # Límites válidos
    x0_px = max(0, min(x0_px, mask_width - 1))
    x1_px = max(0, min(x1_px, mask_width))
    y0_px = max(0, min(y0_px, mask_height - 1))
    y1_px = max(0, min(y1_px, mask_height))
    
    if x1_px <= x0_px or y1_px <= y0_px:
        return False
    
    region = mask[y0_px:y1_px, x0_px:x1_px]
    
    if region.size == 0:
        return False
    
    return np.mean(region) > threshold


def merge_adjacent_rects(rects: List[fitz.Rect]) -> List[fitz.Rect]:
    """
    Fusiona rectángulos adyacentes horizontal y verticalmente.
    Optimización para reducir el número de regiones de clipping.
    """
    if not rects:
        return []
    
    # Fusión horizontal
    sorted_rects = sorted(rects, key=lambda r: (round(r.y0, 2), round(r.x0, 2)))
    h_merged = []
    current = sorted_rects[0]
    
    for rect in sorted_rects[1:]:
        same_row = abs(current.y0 - rect.y0) < 1 and abs(current.y1 - rect.y1) < 1
        adjacent = abs(current.x1 - rect.x0) < 1
        
        if same_row and adjacent:
            current = fitz.Rect(current.x0, current.y0, rect.x1, rect.y1)
        else:
            h_merged.append(current)
            current = rect
    h_merged.append(current)
    
    # Fusión vertical
    sorted_rects = sorted(h_merged, key=lambda r: (round(r.x0, 2), round(r.y0, 2)))
    v_merged = []
    current = sorted_rects[0]
    
    for rect in sorted_rects[1:]:
        same_col = abs(current.x0 - rect.x0) < 1 and abs(current.x1 - rect.x1) < 1
        adjacent = abs(current.y1 - rect.y0) < 1
        
        if same_col and adjacent:
            current = fitz.Rect(current.x0, current.y0, rect.x1, rect.y1)
        else:
            v_merged.append(current)
            current = rect
    v_merged.append(current)
    
    return v_merged


def create_clipping_path(visible_rects: List[fitz.Rect]) -> str:
    """
    Crea un path de clipping en formato PDF para las regiones visibles.
    
    Returns:
        String con comandos PDF para el clipping path
    """
    if not visible_rects:
        return ""
    
    # Construir path usando comandos PDF
    path_commands = []
    
    for rect in visible_rects:
        # Rectángulo en coordenadas PDF
        x0, y0, x1, y1 = rect.x0, rect.y0, rect.x1, rect.y1
        
        # Comandos PDF: m (moveto), l (lineto), h (closepath)
        path_commands.append(f"{x0:.2f} {y0:.2f} m")  # Mover a esquina inferior izquierda
        path_commands.append(f"{x1:.2f} {y0:.2f} l")  # Línea a esquina inferior derecha
        path_commands.append(f"{x1:.2f} {y1:.2f} l")  # Línea a esquina superior derecha
        path_commands.append(f"{x0:.2f} {y1:.2f} l")  # Línea a esquina superior izquierda
        path_commands.append("h")  # Cerrar path
    
    # Usar regla non-zero winding para áreas múltiples
    path_commands.append("W n")  # W = clip, n = newpath
    
    return "\n".join(path_commands)


def apply_vector_mask(input_pdf: str, mask_path: str, output_pdf: str, 
                     grid_divisions: int = 50) -> None:
    """
    Aplica máscara a PDF insertando clipping path en el stream de contenido.
    
    Esta versión manipula directamente el stream de contenido de cada página
    para insertar comandos de clipping vectorial.
    """
    print(f"Cargando máscara: {mask_path}")
    mask = load_mask(mask_path)
    print(f"  Dimensiones: {mask.shape[1]}x{mask.shape[0]}")
    
    print(f"Abriendo PDF: {input_pdf}")
    doc = fitz.open(input_pdf)
    
    for page_num in range(len(doc)):
        page = doc[page_num]
        page_rect = page.rect
        
        print(f"\nPágina {page_num + 1}/{len(doc)}")
        print(f"  Tamaño: {page_rect.width:.1f}x{page_rect.height:.1f}")
        
        # Crear grilla y determinar celdas visibles
        print(f"  Grilla: {grid_divisions}x{grid_divisions}")
        cells = create_grid_cells(page_rect, grid_divisions)
        
        visible_cells = [
            cell for cell in cells 
            if is_cell_visible(cell, page_rect, mask)
        ]
        
        print(f"  Visibles: {len(visible_cells)}/{len(cells)}")
        
        # Optimizar rectángulos
        visible_rects = merge_adjacent_rects(visible_cells)
        print(f"  Optimizados: {len(visible_rects)} rectángulos")
        
        # Obtener contenido actual de la página
        content_stream = page.read_contents()
        
        # Crear path de clipping
        clip_path = create_clipping_path(visible_rects)
        
        # Insertar clipping al inicio del stream
        # El clipping afecta todo el contenido que viene después
        new_content = f"q\n{clip_path}\n".encode() + content_stream + b"\nQ"
        
        # Limpiar contenido anterior
        page.clean_contents()
        
        # Establecer nuevo contenido con clipping
        page.set_contents(new_content)
    
    print(f"\nGuardando: {output_pdf}")
    doc.save(output_pdf, garbage=4, deflate=True, clean=True)
    doc.close()
    print("✓ Completado")


def apply_overlay_mask(input_pdf: str, mask_path: str, output_pdf: str, 
                      grid_divisions: int = 50) -> None:
    """
    Aplica máscara usando overlay de rectángulos blancos sobre áreas ocultas.
    
    Método alternativo más simple y compatible que no requiere manipular
    el stream de contenido directamente.
    """
    print(f"Cargando máscara: {mask_path}")
    mask = load_mask(mask_path)
    print(f"  Dimensiones: {mask.shape[1]}x{mask.shape[0]}")
    
    print(f"Abriendo PDF: {input_pdf}")
    doc = fitz.open(input_pdf)
    
    for page_num in range(len(doc)):
        page = doc[page_num]
        page_rect = page.rect
        
        print(f"\nPágina {page_num + 1}/{len(doc)}")
        
        # Crear grilla
        cells = create_grid_cells(page_rect, grid_divisions)
        
        # Identificar celdas ocultas
        hidden_cells = [
            cell for cell in cells 
            if not is_cell_visible(cell, page_rect, mask)
        ]
        
        print(f"  Ocultas: {len(hidden_cells)}/{len(cells)}")
        
        # Optimizar
        hidden_rects = merge_adjacent_rects(hidden_cells)
        print(f"  Optimizados: {len(hidden_rects)} rectángulos")
        
        # Dibujar rectángulos blancos sobre áreas ocultas
        shape = page.new_shape()
        
        for rect in hidden_rects:
            shape.draw_rect(rect)
            shape.finish(
                fill=fitz.utils.getColor("white"),
                color=None,  # Sin borde
                width=0
            )
        
        shape.commit()
    
    print(f"\nGuardando: {output_pdf}")
    doc.save(output_pdf, garbage=4, deflate=True)
    doc.close()
    print("✓ Completado")


def main():
    """Función principal."""
    import sys
    
    # Configuración
    input_pdf = "input.pdf"
    mask_path = "mask.png"
    output_pdf = "output_masked.pdf"
    grid_divisions = 100
    method = "overlay"  # "overlay" o "clip"
    
    print("=" * 70)
    print("VECTOR PDF MASKING TOOL")
    print("=" * 70)
    print(f"Input: {input_pdf}")
    print(f"Mask: {mask_path}")
    print(f"Output: {output_pdf}")
    print(f"Grid: {grid_divisions}x{grid_divisions}")
    print(f"Method: {method}")
    print("=" * 70)
    
    try:
        if method == "clip":
            # Método avanzado: clipping path en stream
            apply_vector_mask(input_pdf, mask_path, output_pdf, grid_divisions)
        else:
            # Método overlay: rectángulos blancos
            apply_overlay_mask(input_pdf, mask_path, output_pdf, grid_divisions)
            
    except FileNotFoundError as e:
        print(f"\n❌ Archivo no encontrado: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\n❌ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
