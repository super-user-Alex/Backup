"""
pdf_recreator.py
================
Itera por cada elemento de un PDF (texto, imágenes, vectores, bloques)
usando PyMuPDF (fitz) y recrea el documento en un nuevo PDF.

Uso:
    python pdf_recreator.py input.pdf [output.pdf]

Dependencias:
    pip install pymupdf
"""

import sys
import io
import fitz  # PyMuPDF


def recrear_pdf(input_path: str, output_path: str) -> None:
    # ── Abrir documento fuente ──────────────────────────────────────────────
    src = fitz.open(input_path)
    dst = fitz.open()  # Nuevo documento vacío

    for page_num, src_page in enumerate(src):
        print(f"\n{'='*60}")
        print(f"  Página {page_num + 1} de {len(src)}")
        print(f"{'='*60}")

        # Crear página destino con las mismas dimensiones
        rect = src_page.rect
        dst_page = dst.new_page(width=rect.width, height=rect.height)

        # ── 1. VECTORES / PATHS (líneas, rectángulos, curvas, rellenos) ────
        _procesar_vectores(src_page, dst_page)

        # ── 2. IMÁGENES ────────────────────────────────────────────────────
        _procesar_imagenes(src_page, dst_page, src)

        # ── 3. TEXTO (bloques y spans con formato) ─────────────────────────
        _procesar_texto(src_page, dst_page)

        # ── 4. ANOTACIONES (links, comentarios, resaltados…) ───────────────
        _procesar_anotaciones(src_page, dst_page)

    dst.save(output_path, garbage=4, deflate=True)
    print(f"\n✅  PDF recreado guardado en: {output_path}")
    src.close()
    dst.close()


# ─────────────────────────────────────────────────────────────────────────────
# VECTORES
# ─────────────────────────────────────────────────────────────────────────────
def _procesar_vectores(src_page: fitz.Page, dst_page: fitz.Page) -> None:
    """
    Extrae y redibuja todos los paths vectoriales de la página.
    Cada path puede ser una línea, polilínea, curva Bezier,
    rectángulo o forma arbitraria con relleno y/o borde.
    """
    paths = src_page.get_drawings()
    print(f"  ▸ Vectores/Paths encontrados: {len(paths)}")

    shape = dst_page.new_shape()

    for path in paths:
        color       = path.get("color")        # color de borde  (RGB tuple o None)
        fill        = path.get("fill")         # color de relleno (RGB tuple o None)
        width       = path.get("width", 1)     # grosor de línea
        dashes      = path.get("dashes", "")   # patrón de guiones
        line_cap    = path.get("lineCap", 0)
        line_join   = path.get("lineJoin", 0)
        fill_eo     = path.get("even_odd", False)  # regla de relleno

        # Iterar sobre los segmentos del path
        for item in path.get("items", []):
            kind = item[0]

            if kind == "l":          # línea recta
                shape.draw_line(item[1], item[2])

            elif kind == "re":       # rectángulo
                shape.draw_rect(item[1])

            elif kind == "qu":       # quad (cuadrilátero)
                shape.draw_quad(item[1])

            elif kind == "c":        # curva Bezier cúbica
                shape.draw_bezier(item[1], item[2], item[3], item[4])

            elif kind == "v":        # curva Bezier (primer punto = punto actual)
                # fitz no expone draw_v directamente; lo convertimos a bezier
                # usando el punto de inicio implícito (lo omitimos aquí con draw_bezier)
                shape.draw_bezier(item[1], item[1], item[2], item[3])

        # Finalizar path con color y relleno
        shape.finish(
            color=color,
            fill=fill,
            width=width,
            dashes=dashes,
            lineCap=line_cap,
            lineJoin=line_join,
            even_odd=fill_eo,
            closePath=path.get("closePath", False),
        )

    shape.commit()


# ─────────────────────────────────────────────────────────────────────────────
# IMÁGENES
# ─────────────────────────────────────────────────────────────────────────────
def _procesar_imagenes(
    src_page: fitz.Page, dst_page: fitz.Page, src_doc: fitz.Document
) -> None:
    """
    Extrae cada imagen incrustada (raster) de la página y la inserta
    en la página destino respetando su posición y tamaño originales.
    """
    img_list = src_page.get_images(full=True)
    print(f"  ▸ Imágenes encontradas:        {len(img_list)}")

    for img_info in img_list:
        xref      = img_info[0]   # referencia interna del objeto imagen
        smask     = img_info[1]   # máscara de transparencia (si existe)

        # Obtener los bytes de la imagen
        base_image = src_doc.extract_image(xref)
        img_bytes  = base_image["image"]
        img_ext    = base_image["ext"]         # "png", "jpeg", etc.

        # Buscar el rectángulo donde está posicionada la imagen en la página
        img_rect = _buscar_rect_imagen(src_page, xref)

        if img_rect:
            print(f"    → xref={xref}, formato={img_ext}, rect={img_rect}")
            dst_page.insert_image(
                img_rect,
                stream=img_bytes,
                keep_proportion=False,   # respetar exactamente el rect original
            )
        else:
            # Si no se encuentra posición, insertar en toda la página
            print(f"    → xref={xref}, formato={img_ext} (rect no encontrado, usando página completa)")
            dst_page.insert_image(dst_page.rect, stream=img_bytes)


def _buscar_rect_imagen(page: fitz.Page, xref: int) -> fitz.Rect | None:
    """
    Recorre el diccionario de bloques de la página para localizar
    el rectángulo de posicionamiento de la imagen con el xref dado.
    """
    for block in page.get_text("rawdict", flags=fitz.TEXT_PRESERVE_IMAGES)["blocks"]:
        if block.get("type") == 1:  # bloque de imagen
            if block.get("number") == xref or True:
                return fitz.Rect(block["bbox"])
    return None


# ─────────────────────────────────────────────────────────────────────────────
# TEXTO
# ─────────────────────────────────────────────────────────────────────────────
def _procesar_texto(src_page: fitz.Page, dst_page: fitz.Page) -> None:
    """
    Extrae el texto con su formato (fuente, tamaño, color, flags)
    usando 'rawdict' y lo reinserta span a span en la página destino.

    Tipos de bloque:
        0 → bloque de texto
        1 → bloque de imagen (manejado en _procesar_imagenes)
    """
    raw = src_page.get_text("rawdict", flags=fitz.TEXT_PRESERVE_WHITESPACE)
    bloques_texto = [b for b in raw["blocks"] if b["type"] == 0]
    print(f"  ▸ Bloques de texto encontrados: {len(bloques_texto)}")

    total_spans = 0

    for block in bloques_texto:
        for line in block.get("lines", []):
            for span in line.get("spans", []):
                texto  = span.get("text", "").strip()
                if not texto:
                    continue

                total_spans += 1
                origen = fitz.Point(span["origin"])   # punto base del texto
                size   = span.get("size", 11)
                color  = _int_to_rgb(span.get("color", 0))
                flags  = span.get("flags", 0)         # bold, italic, etc.
                font   = _fuente_segura(span.get("font", "helv"), flags)

                dst_page.insert_text(
                    origen,
                    texto,
                    fontsize=size,
                    color=color,
                    fontname=font,
                    rotate=0,
                )

    print(f"    → Spans de texto insertados: {total_spans}")


def _int_to_rgb(color_int: int) -> tuple:
    """Convierte un entero de color sRGB (ej. 0xFF0000) a tupla (r, g, b) en [0,1]."""
    r = ((color_int >> 16) & 0xFF) / 255
    g = ((color_int >> 8)  & 0xFF) / 255
    b = ( color_int        & 0xFF) / 255
    return (r, g, b)


def _fuente_segura(font_name: str, flags: int) -> str:
    """
    Mapea el nombre de fuente del documento original a una de las fuentes
    base de PDF (siempre disponibles) según si es bold/italic.
    Esto evita errores por fuentes no incrustadas.

    flags bit 0 → superscript
    flags bit 1 → italic
    flags bit 4 → bold
    """
    is_bold   = bool(flags & (1 << 4))
    is_italic = bool(flags & (1 << 1))

    if is_bold and is_italic:
        return "Times-BoldItalic"
    elif is_bold:
        return "Helvetica-Bold"
    elif is_italic:
        return "Helvetica-Oblique"
    else:
        return "Helvetica"


# ─────────────────────────────────────────────────────────────────────────────
# ANOTACIONES
# ─────────────────────────────────────────────────────────────────────────────
def _procesar_anotaciones(src_page: fitz.Page, dst_page: fitz.Page) -> None:
    """
    Copia las anotaciones visibles (resaltados, subrayados, cuadros de texto,
    notas adhesivas, tachados) de la página origen a la destino.
    Los links se manejan por separado.
    """
    annots = list(src_page.annots())
    print(f"  ▸ Anotaciones encontradas:      {len(annots)}")

    TIPOS_SOPORTADOS = {
        fitz.PDF_ANNOT_HIGHLIGHT,
        fitz.PDF_ANNOT_UNDERLINE,
        fitz.PDF_ANNOT_STRIKEOUT,
        fitz.PDF_ANNOT_SQUIGGLY,
        fitz.PDF_ANNOT_TEXT,
        fitz.PDF_ANNOT_FREE_TEXT,
        fitz.PDF_ANNOT_SQUARE,
        fitz.PDF_ANNOT_CIRCLE,
        fitz.PDF_ANNOT_LINE,
        fitz.PDF_ANNOT_POLYGON,
        fitz.PDF_ANNOT_POLY_LINE,
        fitz.PDF_ANNOT_INK,
    }

    for annot in annots:
        tipo = annot.type[0]
        if tipo not in TIPOS_SOPORTADOS:
            continue

        try:
            nueva = dst_page.add_annot(tipo)
            nueva.set_rect(annot.rect)
            nueva.set_colors(
                stroke=annot.colors.get("stroke"),
                fill=annot.colors.get("fill"),
            )
            nueva.set_opacity(annot.opacity)

            # Contenido de texto (para notas adhesivas y free text)
            if annot.info.get("content"):
                nueva.set_info(content=annot.info["content"])

            nueva.update()
        except Exception as e:
            print(f"    ⚠ No se pudo copiar anotación tipo {annot.type[1]}: {e}")

    # ── Links (URIs e internos) ─────────────────────────────────────────────
    links = src_page.get_links()
    print(f"  ▸ Links encontrados:            {len(links)}")
    for link in links:
        dst_page.insert_link(link)


# ─────────────────────────────────────────────────────────────────────────────
# ENTRY POINT
# ─────────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Uso: python pdf_recreator.py input.pdf [output.pdf]")
        sys.exit(1)

    input_pdf  = sys.argv[1]
    output_pdf = sys.argv[2] if len(sys.argv) > 2 else "output_recreado.pdf"

    recrear_pdf(input_pdf, output_pdf)
