# """
# clip_to_polygon.py
# ==================
# Extensión de pymupdf.clip_to_rect() que acepta un polígono arbitrario
# y mantiene las propiedades vectoriales del PDF.

# Estrategia:
#   - Se dibuja el polígono como un "clipping path" en el content stream
#     de la página usando el operador PDF 'W n' (clip path).
#   - Todo el contenido original de la página queda encapsulado dentro
#     de un bloque q … Q (save/restore graphics state), con el clip activo.
#   - El resultado es 100 % vectorial: texto, paths y formas siguen siendo
#     vectores, no se rasterizan.

# Dependencias:
#     pip install pymupdf shapely
# """

# import fitz          # PyMuPDF
# from shapely.geometry import Polygon as ShapelyPolygon


# # ---------------------------------------------------------------------------
# # Función principal
# # ---------------------------------------------------------------------------

# def clip_to_polygon(
#     input_path: str,
#     output_path: str,
#     polygon: list[tuple[float, float]],
#     page_index: int = 0,
#     *,
#     keep_other_pages: bool = True,
# ) -> None:
#     """
#     Recorta una página de un PDF a un polígono arbitrario manteniendo
#     propiedades vectoriales (sin rasterización).

#     Parameters
#     ----------
#     input_path : str
#         Ruta al PDF de entrada.
#     output_path : str
#         Ruta donde se guardará el PDF resultante.
#     polygon : list of (x, y) tuples
#         Vértices del polígono en coordenadas de la página (puntos PDF,
#         origen en la esquina inferior-izquierda por convención de PyMuPDF).
#         El polígono se cierra automáticamente.
#     page_index : int
#         Índice (0-based) de la página a recortar.
#     keep_other_pages : bool
#         Si True, conserva el resto de páginas sin modificar.
#         Si False, el PDF resultante tendrá solo la página recortada.
#     """
#     if len(polygon) < 3:
#         raise ValueError("El polígono debe tener al menos 3 vértices.")

#     # Validar / limpiar con Shapely (elimina auto-intersecciones, etc.)
#     shapely_poly = ShapelyPolygon(polygon)
#     if not shapely_poly.is_valid:
#         shapely_poly = shapely_poly.buffer(0)   # auto-reparación común
#     if not shapely_poly.is_valid:
#         raise ValueError("El polígono proporcionado no es válido.")

#     # Tomar vértices del exterior (puede haber sido simplificado por Shapely)
#     clean_vertices = list(shapely_poly.exterior.coords)[:-1]  # sin el punto de cierre repetido

#     doc = fitz.open(input_path)
#     page = doc[page_index]

#     # ------------------------------------------------------------------
#     # Construir el clipping path como fragmento de PDF content stream.
#     #
#     # Estructura:
#     #   q                        ← guardar estado gráfico
#     #   x0 y0 m                  ← moveTo primer vértice
#     #   x1 y1 l                  ← lineTo siguientes vértices
#     #   ...
#     #   h                        ← cerrar path
#     #   W n                      ← establecer clip path (nonzero winding),
#     #                               'n' descarta el path sin pintarlo
#     #   <contenido original>     ← queda dentro del clip
#     #   Q                        ← restaurar estado (elimina el clip)
#     # ------------------------------------------------------------------

#     clip_ops = _build_clip_stream(clean_vertices)

#     # Envolver el contenido existente de la página
#     _apply_clip_to_page(page, clip_ops)

#     # Recortar también el mediabox / cropbox al bounding rect del polígono
#     # (opcional pero mejora la visualización en visores)
#     bbox = shapely_poly.bounds  # (minx, miny, maxx, maxy)
#     page_rect = page.rect       # rect actual de la página

#     # Shapely usa el mismo sistema de coordenadas que PyMuPDF (y hacia abajo
#     # cuando se trabaja con coordenadas de pantalla). Si tu polígono usa
#     # coordenadas PDF puras (y hacia arriba) el bounding box es correcto tal cual.
#     clip_rect = fitz.Rect(
#         max(bbox[0], page_rect.x0),
#         max(bbox[1], page_rect.y0),
#         min(bbox[2], page_rect.x1),
#         min(bbox[3], page_rect.y1),
#     )
#     page.set_cropbox(clip_rect)

#     if not keep_other_pages:
#         # Eliminar todas las páginas excepto la procesada
#         pages_to_delete = [i for i in range(len(doc)) if i != page_index]
#         for i in sorted(pages_to_delete, reverse=True):
#             doc.delete_page(i)

#     doc.save(output_path, garbage=4, deflate=True)
#     doc.close()
#     print(f"PDF guardado en: {output_path}")


# # ---------------------------------------------------------------------------
# # Helpers internos
# # ---------------------------------------------------------------------------

# def _build_clip_stream(vertices: list[tuple[float, float]]) -> tuple[bytes, bytes]:
#     """
#     Genera los fragmentos de content stream para abrir (prefix) y
#     cerrar (suffix) el clipping path.

#     Returns
#     -------
#     prefix : bytes   → se antepone al contenido original
#     suffix : bytes   → se pospone al contenido original
#     """
#     lines = []
#     for i, (x, y) in enumerate(vertices):
#         op = "m" if i == 0 else "l"
#         lines.append(f"{x:.4f} {y:.4f} {op}")
#     lines.append("h")   # cerrar path
#     lines.append("W n") # clip path + no-paint

#     prefix = b"q\n" + "\n".join(lines).encode() + b"\n"
#     suffix = b"\nQ\n"
#     return prefix, suffix


# def _apply_clip_to_page(page: fitz.Page, clip_ops: tuple[bytes, bytes]) -> None:
#     """
#     Envuelve el content stream existente de la página con q…W n…Q.
#     """
#     prefix, suffix = clip_ops

#     # Obtener el content stream actual (puede ser un array de streams)
#     xref = page.xref                          # xref del objeto página
#     doc  = page.parent

#     # Leer el stream completo de la página (PyMuPDF lo concatena si hay varios)
#     original_stream = page.read_contents()    # bytes

#     # Componer el nuevo stream
#     new_stream = prefix + original_stream + suffix

#     # Reemplazar el contenido
#     page.clean_contents()                     # normaliza en un solo stream
#     doc.update_stream(page.get_contents()[0], new_stream)


# # ---------------------------------------------------------------------------
# # Utilidad: clip_polygon_to_new_page
# # ---------------------------------------------------------------------------

# def extract_polygon_region(
#     input_path: str,
#     output_path: str,
#     polygon: list[tuple[float, float]],
#     page_index: int = 0,
# ) -> None:
#     """
#     Variante de clip_to_polygon que además crea una nueva página cuyo
#     tamaño coincide exactamente con el bounding box del polígono.
#     """
#     clip_to_polygon(
#         input_path,
#         output_path,
#         polygon,
#         page_index=page_index,
#         keep_other_pages=False,
#     )
#     # Ajustar mediabox al bounding rect ya fue hecho en clip_to_polygon via set_cropbox


# # ---------------------------------------------------------------------------
# # Ejemplo de uso
# # ---------------------------------------------------------------------------

# if __name__ == "__main__":
#     import sys

#     # Crear un PDF de demostración si no se pasa uno como argumento
#     if len(sys.argv) < 2:
#         # --- Generar PDF de prueba con contenido vectorial ---
#         demo_path = r"demo_input.pdf"
#         doc = fitz.open()
#         page = doc.new_page(width=400, height=400)

#         # Texto vectorial
#         page.insert_text((50, 100), "Texto vectorial en PDF", fontsize=18, color=(0, 0, 0.8))
#         page.insert_text((50, 140), "Segunda línea de ejemplo", fontsize=14)

#         # Formas vectoriales
#         page.draw_rect(fitz.Rect(30, 160, 370, 350), color=(0.8, 0, 0), fill=(1, 0.9, 0.9), width=2)
#         page.draw_circle(fitz.Point(200, 255), 80, color=(0, 0.6, 0), fill=(0.8, 1, 0.8), width=2)
#         page.draw_line(fitz.Point(30, 370), fitz.Point(370, 370), color=(0.5, 0.5, 0.5), width=1)

#         doc.save(demo_path)
#         doc.close()

#         input_pdf  = demo_path
#         output_pdf = r"demo_clipped.pdf"
#     else:
#         input_pdf  = sys.argv[1]
#         output_pdf = sys.argv[2] if len(sys.argv) > 2 else r"clipped_output.pdf"

#     # Polígono de ejemplo: triángulo central
#     triangle = [
#         (200, 50),   # vértice superior (centro)
#         (370, 370),  # inferior derecho
#         (30,  370),  # inferior izquierdo
#     ]

#     # Polígono más complejo: hexágono
#     import math
#     cx, cy, r = 200, 200, 160
#     hexagon = [
#         (cx + r * math.cos(math.radians(60 * i - 30)),
#          cy + r * math.sin(math.radians(60 * i - 30)))
#         for i in range(6)
#     ]

#     print("Aplicando clip poligonal (hexágono) al PDF de demo…")
#     clip_to_polygon(input_pdf, output_pdf, hexagon, page_index=0)
#     print("✓ Listo. Abre:", output_pdf)


# # Hexágono, triángulo, o cualquier forma
# # hexagon = [(200,40), (340,120), (340,280), (200,360), (60,280), (60,120)]

# # clip_to_polygon("entrada.pdf", "salida.pdf", hexagon, page_index=0)


"""
clip_to_polygon.py
==================
Extensión de pymupdf.clip_to_rect() que acepta un polígono arbitrario
y mantiene las propiedades vectoriales del PDF.

Estrategia:
  - Se dibuja el polígono como un "clipping path" en el content stream
    de la página usando el operador PDF 'W n' (clip path).
  - Todo el contenido original de la página queda encapsulado dentro
    de un bloque q … Q (save/restore graphics state), con el clip activo.
  - El resultado es 100% vectorial: texto, paths y formas siguen siendo
    vectores, no se rasterizan.

Dependencias:
    pip install pymupdf shapely
"""

import math
import fitz  # PyMuPDF
from shapely.geometry import Polygon as ShapelyPolygon


# ─────────────────────────────────────────────────────────────────────────────
# Función principal
# ─────────────────────────────────────────────────────────────────────────────

def clip_to_polygon(
    input_path: str,
    output_path: str,
    polygon: list[tuple[float, float]],
    page_index: int = 0,
    *,
    keep_other_pages: bool = True,
) -> None:
    """
    Recorta una página de un PDF a un polígono arbitrario manteniendo
    propiedades vectoriales (sin rasterización).

    Parameters
    ----------
    input_path : str
        Ruta al PDF de entrada.
    output_path : str
        Ruta donde se guardará el PDF resultante.
    polygon : list of (x, y) tuples
        Vértices del polígono en coordenadas de la página (puntos PDF).
        El polígono se cierra automáticamente.
    page_index : int
        Índice (0-based) de la página a recortar.
    keep_other_pages : bool
        Si True, conserva el resto de páginas sin modificar.
        Si False, el PDF resultante tendrá solo la página recortada.
    """
    if len(polygon) < 3:
        raise ValueError("El polígono debe tener al menos 3 vértices.")

    shapely_poly = _validate_polygon(polygon)
    clean_vertices = list(shapely_poly.exterior.coords)[:-1]

    doc = fitz.open(input_path)
    page = doc[page_index]

    clip_ops = _build_clip_stream(clean_vertices)
    _apply_clip_to_page(page, clip_ops)

    bbox = shapely_poly.bounds  # (minx, miny, maxx, maxy)
    page_rect = page.rect
    clip_rect = fitz.Rect(
        max(bbox[0], page_rect.x0),
        max(bbox[1], page_rect.y0),
        min(bbox[2], page_rect.x1),
        min(bbox[3], page_rect.y1),
    )
    page.set_cropbox(clip_rect)

    if not keep_other_pages:
        pages_to_delete = [i for i in range(len(doc)) if i != page_index]
        for i in sorted(pages_to_delete, reverse=True):
            doc.delete_page(i)

    doc.save(output_path, garbage=4, deflate=True)
    doc.close()
    print(f"✓ PDF recortado guardado en: {output_path}")


# ─────────────────────────────────────────────────────────────────────────────
# Preview: ver dónde quedaría el polígono sobre la página
# ─────────────────────────────────────────────────────────────────────────────

def preview_polygon(
    input_path: str,
    output_path: str,
    polygon: list[tuple[float, float]],
    page_index: int = 0,
    *,
    fill_color: tuple = (0.2, 0.6, 1.0),
    fill_opacity: float = 0.25,
    border_color: tuple = (0.0, 0.3, 0.9),
    border_width: float = 2.0,
    show_vertices: bool = True,
    vertex_radius: float = 4.0,
    vertex_color: tuple = (1.0, 0.2, 0.2),
    show_labels: bool = True,
    label_fontsize: float = 9,
    show_bounding_box: bool = True,
    bbox_color: tuple = (0.5, 0.5, 0.5),
    show_dimensions: bool = True,
) -> None:
    """
    Genera un PDF de preview que muestra el contenido original de la página
    con el polígono de clip superpuesto (semitransparente), sin modificar
    el contenido real.

    Útil para verificar la posición del polígono ANTES de aplicar el clip.

    Parameters
    ----------
    input_path : str
        PDF de entrada (solo lectura).
    output_path : str
        PDF de salida con el overlay del polígono.
    polygon : list of (x, y) tuples
        Vértices del polígono a visualizar.
    page_index : int
        Página sobre la que dibujar.
    fill_color : (r, g, b)
        Color de relleno del polígono (valores 0–1).
    fill_opacity : float
        Opacidad del relleno (0 = transparente, 1 = sólido).
    border_color : (r, g, b)
        Color del borde del polígono.
    border_width : float
        Grosor del borde en puntos.
    show_vertices : bool
        Si True, marca cada vértice con un círculo.
    vertex_radius : float
        Radio de los círculos de vértice.
    vertex_color : (r, g, b)
        Color de los círculos de vértice.
    show_labels : bool
        Si True, numera cada vértice (V0, V1, …) con sus coordenadas.
    label_fontsize : float
        Tamaño de fuente de las etiquetas.
    show_bounding_box : bool
        Si True, dibuja el bounding rect del polígono con línea punteada.
    bbox_color : (r, g, b)
        Color del bounding box.
    show_dimensions : bool
        Si True, añade una leyenda con área, perímetro y bounding box.
    """
    if len(polygon) < 3:
        raise ValueError("El polígono debe tener al menos 3 vértices.")

    shapely_poly = _validate_polygon(polygon)

    doc = fitz.open(input_path)
    page = doc[page_index]

    # ── Polígono relleno (semitransparente) ──────────────────────────────────
    pts = [fitz.Point(x, y) for x, y in polygon]
    shape = page.new_shape()
    shape.draw_polyline(pts)
    shape.draw_line(pts[-1], pts[0])
    shape.finish(
        fill=fill_color,
        color=border_color,
        width=border_width,
        fill_opacity=fill_opacity,
        stroke_opacity=1.0,
        closePath=True,
    )

    # ── Bounding box punteado ────────────────────────────────────────────────
    if show_bounding_box:
        b = shapely_poly.bounds
        shape.draw_rect(fitz.Rect(b[0], b[1], b[2], b[3]))
        shape.finish(
            color=bbox_color,
            width=1.0,
            dashes="[4 4] 0",
            fill=None,
        )

    # ── Vértices ─────────────────────────────────────────────────────────────
    if show_vertices:
        for i, (x, y) in enumerate(polygon):
            shape.draw_circle(fitz.Point(x, y), vertex_radius)
            shape.finish(fill=vertex_color, color=(1, 1, 1), width=1.0)
            if show_labels:
                offset_x = vertex_radius + 3
                offset_y = -(vertex_radius + 2)
                page.insert_text(
                    fitz.Point(x + offset_x, y + offset_y),
                    f"V{i} ({x:.0f},{y:.0f})",
                    fontsize=label_fontsize,
                    color=(0, 0, 0),
                )

    shape.commit()

    # ── Leyenda de dimensiones ───────────────────────────────────────────────
    if show_dimensions:
        area      = shapely_poly.area
        perimeter = shapely_poly.length
        b         = shapely_poly.bounds
        bw, bh    = b[2] - b[0], b[3] - b[1]
        cx, cy    = shapely_poly.centroid.x, shapely_poly.centroid.y

        info_lines = [
            f"Vértices : {len(polygon)}",
            f"Área     : {area:.1f} pt²  ({area / 5765.76:.3f} cm²)",
            f"Perímetro: {perimeter:.1f} pt  ({perimeter * 0.0352778:.2f} cm)",
            f"BBox W×H : {bw:.1f} × {bh:.1f} pt",
            f"Centroide: ({cx:.1f}, {cy:.1f})",
        ]

        margin  = 10
        line_h  = label_fontsize + 4
        box_w   = 230
        box_h   = len(info_lines) * line_h + 12
        pr      = page.rect
        legend  = fitz.Rect(
            pr.x0 + margin,
            pr.y1 - margin - box_h,
            pr.x0 + margin + box_w,
            pr.y1 - margin,
        )

        shape2 = page.new_shape()
        shape2.draw_rect(legend)
        shape2.finish(fill=(1, 1, 0.9), color=(0.4, 0.4, 0.4), width=0.8,
                      fill_opacity=0.90)
        shape2.commit()

        for i, line in enumerate(info_lines):
            page.insert_text(
                fitz.Point(legend.x0 + 7, legend.y0 + 14 + i * line_h),
                line,
                fontsize=label_fontsize,
                color=(0.1, 0.1, 0.1),
            )

    doc.save(output_path, garbage=4, deflate=True)
    doc.close()
    print(f"✓ Preview guardado en: {output_path}")


def preview_multiple_polygons(
    input_path: str,
    output_path: str,
    polygons: list[dict],
    page_index: int = 0,
) -> None:
    """
    Preview de múltiples polígonos sobre la misma página, cada uno con
    su propio color y etiqueta.

    Parameters
    ----------
    polygons : list of dict
        Cada dict puede tener:
          - 'polygon'  : list[(x,y)]  (requerido)
          - 'label'    : str          (opcional)
          - 'color'    : (r,g,b)      (opcional, se asigna de paleta)
          - 'opacity'  : float        (opcional, default 0.2)
    """
    PALETTE = [
        (0.2, 0.6, 1.0),
        (1.0, 0.4, 0.2),
        (0.2, 0.8, 0.4),
        (0.8, 0.2, 0.8),
        (1.0, 0.75, 0.0),
        (0.0, 0.8, 0.8),
    ]

    doc = fitz.open(input_path)
    page = doc[page_index]

    for idx, poly_def in enumerate(polygons):
        pts_raw = poly_def["polygon"]
        label   = poly_def.get("label", f"Polígono {idx + 1}")
        color   = poly_def.get("color", PALETTE[idx % len(PALETTE)])
        opacity = poly_def.get("opacity", 0.22)

        if len(pts_raw) < 3:
            print(f"⚠  {label}: menos de 3 vértices, se omite.")
            continue

        shapely_poly = _validate_polygon(pts_raw)
        pts = [fitz.Point(x, y) for x, y in pts_raw]
        border = tuple(max(0, c - 0.25) for c in color)

        shape = page.new_shape()
        shape.draw_polyline(pts)
        shape.draw_line(pts[-1], pts[0])
        shape.finish(
            fill=color,
            color=border,
            width=2.0,
            fill_opacity=opacity,
            closePath=True,
        )
        shape.commit()

        cx, cy = shapely_poly.centroid.x, shapely_poly.centroid.y
        page.insert_text(
            fitz.Point(cx - 20, cy + 4),
            label,
            fontsize=10,
            color=(0.05, 0.05, 0.05),
        )

    doc.save(output_path, garbage=4, deflate=True)
    doc.close()
    print(f"✓ Preview múltiple guardado en: {output_path}")


# ─────────────────────────────────────────────────────────────────────────────
# Utilidad adicional
# ─────────────────────────────────────────────────────────────────────────────

def extract_polygon_region(
    input_path: str,
    output_path: str,
    polygon: list[tuple[float, float]],
    page_index: int = 0,
) -> None:
    """
    Clipea la página al polígono y genera un PDF de una sola página cuyo
    cropbox coincide con el bounding box del polígono.
    """
    clip_to_polygon(
        input_path, output_path, polygon,
        page_index=page_index,
        keep_other_pages=False,
    )


# ─────────────────────────────────────────────────────────────────────────────
# Helpers internos
# ─────────────────────────────────────────────────────────────────────────────

def _validate_polygon(polygon: list[tuple[float, float]]) -> ShapelyPolygon:
    poly = ShapelyPolygon(polygon)
    if not poly.is_valid:
        poly = poly.buffer(0)
    if not poly.is_valid:
        raise ValueError("El polígono no es válido y no pudo repararse.")
    return poly


def _build_clip_stream(vertices: list[tuple[float, float]]) -> tuple[bytes, bytes]:
    """Genera los fragmentos de content stream para el clipping path PDF."""
    lines = []
    for i, (x, y) in enumerate(vertices):
        lines.append(f"{x:.4f} {y:.4f} {'m' if i == 0 else 'l'}")
    lines.append("h")    # cerrar path
    lines.append("W n")  # clip path nonzero winding + no-paint
    prefix = b"q\n" + "\n".join(lines).encode() + b"\n"
    suffix = b"\nQ\n"
    return prefix, suffix


def _apply_clip_to_page(page: fitz.Page, clip_ops: tuple[bytes, bytes]) -> None:
    """Envuelve el content stream existente con q … W n … Q."""
    prefix, suffix = clip_ops
    doc = page.parent
    original = page.read_contents()
    new_stream = prefix + original + suffix
    page.clean_contents()
    doc.update_stream(page.get_contents()[0], new_stream)


# ─────────────────────────────────────────────────────────────────────────────
# Generador de PDF de prueba compartido entre los tests
# ─────────────────────────────────────────────────────────────────────────────

def _make_demo_pdf(path: str, width: int = 500, height: int = 600) -> None:
    """Crea un PDF con contenido vectorial variado (texto, formas, curvas)."""
    doc = fitz.open()
    page = doc.new_page(width=width, height=height)

    # Cuadrícula de fondo
    for x in range(0, width, 50):
        page.draw_line(fitz.Point(x, 0), fitz.Point(x, height),
                       color=(0.88, 0.88, 0.88), width=0.5)
    for y in range(0, height, 50):
        page.draw_line(fitz.Point(0, y), fitz.Point(width, y),
                       color=(0.88, 0.88, 0.88), width=0.5)

    # Marcas de coordenadas cada 100px
    for x in range(0, width + 1, 100):
        page.insert_text(fitz.Point(x + 2, 12), str(x),
                         fontsize=7, color=(0.6, 0.6, 0.6))
    for y in range(0, height + 1, 100):
        page.insert_text(fitz.Point(2, y + 8), str(y),
                         fontsize=7, color=(0.6, 0.6, 0.6))

    # Título
    page.insert_text((20, 35), "PDF de prueba — clip_to_polygon",
                     fontsize=16, color=(0.1, 0.1, 0.5))
    page.insert_text((20, 55), "Texto vectorial: áéíóú ñ € ∑ ∞",
                     fontsize=12, color=(0.1, 0.1, 0.1))

    # Rectángulos
    page.draw_rect(fitz.Rect(20, 70, 480, 200),
                   color=(0.8, 0.1, 0.1), fill=(1, 0.92, 0.92), width=2)
    page.draw_rect(fitz.Rect(50, 90, 200, 180),
                   color=(0.1, 0.1, 0.8), fill=(0.9, 0.9, 1.0), width=1.5)

    # Círculos
    page.draw_circle(fitz.Point(350, 135), 55,
                     color=(0, 0.6, 0), fill=(0.85, 1.0, 0.85), width=2)
    page.draw_circle(fitz.Point(120, 135), 35,
                     color=(0.8, 0.5, 0), fill=(1.0, 0.95, 0.8), width=1.5)

    # Texto sobre las formas
    page.insert_text((95, 140), "Hola!", fontsize=14, color=(0.1, 0.1, 0.7))
    page.insert_text((318, 140), "Círculo", fontsize=11, color=(0, 0.5, 0))

    # Curva de Bezier
    page.draw_bezier(
        fitz.Point(30, 230), fitz.Point(160, 185),
        fitz.Point(340, 275), fitz.Point(470, 230),
        color=(0.6, 0, 0.6), width=3,
    )

    # Estrella vectorial
    _draw_star(page, cx=250, cy=340, r_outer=80, r_inner=35, points=5,
               color=(0.85, 0.65, 0), fill=(1.0, 0.95, 0.5))

    # Texto largo
    page.insert_text((20, 460), "Línea de texto larga para probar clipping horizontal",
                     fontsize=11, color=(0, 0, 0))
    page.insert_text((20, 478), "Números: 0123456789  |  Símbolos: @#%&*",
                     fontsize=11, color=(0.3, 0.3, 0.3))

    # Tabla simple
    for row in range(4):
        for col in range(4):
            rx = 20 + col * 115
            ry = 500 + row * 22
            page.draw_rect(fitz.Rect(rx, ry, rx + 112, ry + 20),
                           color=(0.5, 0.5, 0.5), fill=(0.97, 0.97, 1.0), width=0.5)
            page.insert_text(fitz.Point(rx + 4, ry + 14),
                             f"Celda [{row},{col}]", fontsize=8, color=(0, 0, 0))

    doc.save(path)
    doc.close()


def _draw_star(page, cx, cy, r_outer, r_inner, points=5, color=None, fill=None):
    """Dibuja una estrella vectorial de N puntas."""
    pts = []
    for i in range(points * 2):
        r = r_outer if i % 2 == 0 else r_inner
        a = math.radians(-90 + i * 180 / points)
        pts.append(fitz.Point(cx + r * math.cos(a), cy + r * math.sin(a)))
    shape = page.new_shape()
    shape.draw_polyline(pts)
    shape.draw_line(pts[-1], pts[0])
    shape.finish(color=color, fill=fill, width=1.5, closePath=True)
    shape.commit()


def _regular_polygon(cx, cy, r, n, start_deg=-90):
    """Genera los vértices de un polígono regular."""
    return [
        (cx + r * math.cos(math.radians(start_deg + 360 * i / n)),
         cy + r * math.sin(math.radians(start_deg + 360 * i / n)))
        for i in range(n)
    ]

"""
test_clip_to_polygon.py
=======================
Suite de tests para clip_to_polygon.py.

Cubre:
  - Tests unitarios de helpers internos
  - Tests de integración para cada tipo de polígono
  - Tests de preview (single y múltiple)
  - Tests de casos borde y errores esperados
  - Tests de propiedades vectoriales del PDF resultante

Ejecutar:
    pytest test_clip_to_polygon.py -v
    # o sin pytest:
    python test_clip_to_polygon.py
"""

import math
import os
import sys
import tempfile
import unittest

import fitz
from shapely.geometry import Polygon as ShapelyPolygon

# Importar el módulo a testear

# ─────────────────────────────────────────────────────────────────────────────
# Fixtures reutilizables
# ─────────────────────────────────────────────────────────────────────────────

W, H = 500, 600  # dimensiones del PDF de demo

def make_temp_pdf() -> str:
    """Crea un PDF de demo en un archivo temporal y devuelve su ruta."""
    tmp = tempfile.NamedTemporaryFile(suffix=".pdf", delete=False)
    tmp.close()
    _make_demo_pdf(tmp.name, width=W, height=H)
    return tmp.name


def temp_out() -> str:
    """Ruta de archivo temporal para output."""
    tmp = tempfile.NamedTemporaryFile(suffix=".pdf", delete=False)
    tmp.close()
    return tmp.name


# ─────────────────────────────────────────────────────────────────────────────
# 1. Tests unitarios — helpers internos
# ─────────────────────────────────────────────────────────────────────────────

class TestValidatePolygon(unittest.TestCase):
    def test_triangle_valid(self):
        poly = _validate_polygon([(0, 0), (100, 0), (50, 100)])
        self.assertIsInstance(poly, ShapelyPolygon)
        self.assertTrue(poly.is_valid)

    def test_square_valid(self):
        poly = _validate_polygon([(0, 0), (100, 0), (100, 100), (0, 100)])
        self.assertTrue(poly.is_valid)
        self.assertAlmostEqual(poly.area, 10000.0)

    def test_polygon_too_few_vertices_raises(self):
        with self.assertRaises(ValueError):
            clip_to_polygon("x.pdf", "y.pdf", [(0, 0), (1, 1)], 0)

    def test_self_intersecting_is_repaired(self):
        # Mariposa (bowtie) — Shapely lo repara con buffer(0)
        bowtie = [(0, 0), (100, 100), (100, 0), (0, 100)]
        poly = _validate_polygon(bowtie)
        self.assertTrue(poly.is_valid)

    def test_convex_hull_preserved(self):
        hexagon = _regular_polygon(250, 300, 150, 6)
        poly = _validate_polygon(hexagon)
        self.assertEqual(len(poly.exterior.coords) - 1, 6)


class TestBuildClipStream(unittest.TestCase):
    def test_output_is_bytes(self):
        vertices = [(0, 0), (100, 0), (50, 100)]
        prefix, suffix = _build_clip_stream(vertices)
        self.assertIsInstance(prefix, bytes)
        self.assertIsInstance(suffix, bytes)

    def test_prefix_starts_with_q(self):
        prefix, _ = _build_clip_stream([(0, 0), (1, 0), (0, 1)])
        self.assertTrue(prefix.startswith(b"q\n"))

    def test_suffix_ends_with_Q(self):
        _, suffix = _build_clip_stream([(0, 0), (1, 0), (0, 1)])
        self.assertIn(b"Q", suffix)

    def test_prefix_contains_W_n(self):
        prefix, _ = _build_clip_stream([(0, 0), (1, 0), (0, 1)])
        self.assertIn(b"W n", prefix)

    def test_prefix_contains_moveto(self):
        prefix, _ = _build_clip_stream([(10.5, 20.5), (100, 0), (0, 100)])
        self.assertIn(b"10.5000 20.5000 m", prefix)

    def test_prefix_contains_h(self):
        prefix, _ = _build_clip_stream([(0, 0), (1, 0), (0, 1)])
        self.assertIn(b"\nh\n", prefix)

    def test_all_vertices_present(self):
        verts = [(10, 20), (30, 40), (50, 60), (70, 80)]
        prefix, _ = _build_clip_stream(verts)
        for x, y in verts:
            self.assertIn(f"{x:.4f} {y:.4f}".encode(), prefix)


# ─────────────────────────────────────────────────────────────────────────────
# 2. Tests de integración — clip_to_polygon
# ─────────────────────────────────────────────────────────────────────────────

class TestClipToPolygonIntegration(unittest.TestCase):
    def setUp(self):
        self.src = make_temp_pdf()

    def tearDown(self):
        os.unlink(self.src)

    # ── Test 1: Triángulo ────────────────────────────────────────────────────
    def test_triangle_clip(self):
        """Triángulo central que cubre la parte media de la página."""
        triangle = [
            (250, 50),   # vértice superior
            (480, 570),  # inferior derecho
            (20,  570),  # inferior izquierdo
        ]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, triangle)
            doc = fitz.open(out)
            self.assertEqual(len(doc), 1)
            page = doc[0]
            # El cropbox debe estar dentro del page rect original
            self.assertLessEqual(page.rect.width, W)
            self.assertLessEqual(page.rect.height, H)
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 2: Hexágono ─────────────────────────────────────────────────────
    def test_hexagon_clip(self):
        """Hexágono regular centrado."""
        hexagon = _regular_polygon(250, 300, 200, 6)
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, hexagon)
            doc = fitz.open(out)
            self.assertTrue(os.path.getsize(out) > 500)
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 3: Pentágono ────────────────────────────────────────────────────
    def test_pentagon_clip(self):
        """Pentágono regular centrado."""
        pentagon = _regular_polygon(250, 300, 180, 5)
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, pentagon)
            self.assertTrue(os.path.getsize(out) > 200)
        finally:
            os.unlink(out)

    # ── Test 4: Rombo (diamante) ─────────────────────────────────────────────
    def test_diamond_clip(self):
        """Rombo (cuadrado rotado 45°)."""
        diamond = [
            (250,  50),  # arriba
            (480, 300),  # derecha
            (250, 550),  # abajo
            (20,  300),  # izquierda
        ]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, diamond)
            doc = fitz.open(out)
            page = doc[0]
            # Cropbox debe ser ~460×500
            self.assertGreater(page.rect.width, 400)
            self.assertGreater(page.rect.height, 400)
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 5: Forma en L ───────────────────────────────────────────────────
    def test_l_shape_clip(self):
        """Polígono cóncavo en forma de L."""
        l_shape = [
            (20, 20), (250, 20), (250, 250),
            (480, 250), (480, 580), (20, 580),
        ]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, l_shape)
            self.assertTrue(os.path.getsize(out) > 200)
        finally:
            os.unlink(out)

    # ── Test 6: Polígono en esquina superior izquierda ───────────────────────
    def test_top_left_corner_clip(self):
        """Triángulo en la esquina superior izquierda."""
        corner = [(0, 0), (300, 0), (0, 300)]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, corner)
            doc = fitz.open(out)
            page = doc[0]
            # Debe recortar al cuadrante superior izquierdo
            self.assertLessEqual(page.rect.x1, W)
            self.assertLessEqual(page.rect.y1, H)
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 7: Polígono muy pequeño ─────────────────────────────────────────
    def test_tiny_polygon(self):
        """Polígono pequeño (50×50 pt) en el centro."""
        tiny = [(225, 275), (275, 275), (275, 325), (225, 325)]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, tiny)
            doc = fitz.open(out)
            page = doc[0]
            self.assertAlmostEqual(page.rect.width, 50.0, delta=2)
            self.assertAlmostEqual(page.rect.height, 50.0, delta=2)
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 8: Estrella de 8 puntas ─────────────────────────────────────────
    def test_star_clip(self):
        """Polígono en forma de estrella de 8 puntas (cóncavo complejo)."""
        cx, cy = 250, 300
        pts = []
        for i in range(16):
            r = 180 if i % 2 == 0 else 80
            a = math.radians(-90 + i * 22.5)
            pts.append((cx + r * math.cos(a), cy + r * math.sin(a)))
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, pts)
            self.assertTrue(os.path.getsize(out) > 200)
        finally:
            os.unlink(out)

    # ── Test 9: keep_other_pages=False ──────────────────────────────────────
    def test_keep_other_pages_false(self):
        """Con keep_other_pages=False el resultado tiene 1 sola página."""
        triangle = [(250, 50), (480, 570), (20, 570)]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, triangle, keep_other_pages=False)
            doc = fitz.open(out)
            self.assertEqual(len(doc), 1)
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 10: Archivo de salida es un PDF válido ──────────────────────────
    def test_output_is_valid_pdf(self):
        """Verificar que el output es un PDF válido (empieza con %PDF-)."""
        poly = _regular_polygon(250, 300, 150, 6)
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, poly)
            with open(out, "rb") as f:
                header = f.read(5)
            self.assertEqual(header, b"%PDF-")
        finally:
            os.unlink(out)

    # ── Test 11: Propiedades vectoriales — no hay imágenes raster ────────────
    def test_no_raster_images_in_output(self):
        """El output no debe contener imágenes rasterizadas."""
        poly = _regular_polygon(250, 300, 200, 6)
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, poly)
            doc = fitz.open(out)
            page = doc[0]
            images = page.get_images(full=True)
            self.assertEqual(len(images), 0,
                             "El clip vectorial no debe añadir imágenes raster")
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 12: Content stream contiene el operador de clip ─────────────────
    def test_content_stream_has_clip_operator(self):
        """El content stream del PDF resultante debe contener 'W n'."""
        poly = [(100, 100), (400, 100), (400, 500), (100, 500)]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, poly)
            doc = fitz.open(out)
            page = doc[0]
            stream = page.read_contents()
            self.assertIn(b"W n", stream,
                          "El content stream debe incluir el operador de clip 'W n'")
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 13: Content stream contiene q y Q ────────────────────────────────
    def test_content_stream_has_q_Q(self):
        """El content stream debe tener save/restore de estado (q … Q)."""
        poly = [(50, 50), (450, 50), (450, 550), (50, 550)]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, poly)
            doc = fitz.open(out)
            stream = doc[0].read_contents()
            self.assertIn(b"q\n", stream)
            self.assertIn(b"Q\n", stream)
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 14: extract_polygon_region ──────────────────────────────────────
    def test_extract_polygon_region(self):
        """extract_polygon_region produce un PDF de una sola página."""
        poly = _regular_polygon(250, 300, 150, 5)
        out = temp_out()
        try:
            extract_polygon_region(self.src, out, poly)
            doc = fitz.open(out)
            self.assertEqual(len(doc), 1)
            doc.close()
        finally:
            os.unlink(out)

    # ── Test 15: Polígono con muchos vértices (curva aproximada) ─────────────
    def test_high_vertex_count_polygon(self):
        """Polígono de 72 vértices (aproximación de un círculo)."""
        circle_approx = _regular_polygon(250, 300, 180, 72)
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, circle_approx)
            self.assertTrue(os.path.getsize(out) > 200)
        finally:
            os.unlink(out)


# ─────────────────────────────────────────────────────────────────────────────
# 3. Tests de preview
# ─────────────────────────────────────────────────────────────────────────────

class TestPreviewPolygon(unittest.TestCase):
    def setUp(self):
        self.src = make_temp_pdf()

    def tearDown(self):
        os.unlink(self.src)

    def test_preview_creates_file(self):
        poly = _regular_polygon(250, 300, 180, 6)
        out = temp_out()
        try:
            preview_polygon(self.src, out, poly)
            self.assertTrue(os.path.exists(out))
            self.assertGreater(os.path.getsize(out), 1000)
        finally:
            os.unlink(out)

    def test_preview_is_valid_pdf(self):
        poly = [(100, 100), (400, 100), (250, 450)]
        out = temp_out()
        try:
            preview_polygon(self.src, out, poly)
            with open(out, "rb") as f:
                self.assertEqual(f.read(4), b"%PDF")
        finally:
            os.unlink(out)

    def test_preview_preserves_page_count(self):
        """Preview no debe cambiar el número de páginas."""
        poly = _regular_polygon(250, 300, 150, 5)
        out = temp_out()
        try:
            preview_polygon(self.src, out, poly)
            src_doc = fitz.open(self.src)
            out_doc = fitz.open(out)
            self.assertEqual(len(src_doc), len(out_doc))
            src_doc.close()
            out_doc.close()
        finally:
            os.unlink(out)

    def test_preview_no_vertices(self):
        """Preview sin etiquetas de vértices."""
        poly = _regular_polygon(250, 300, 160, 4)
        out = temp_out()
        try:
            preview_polygon(self.src, out, poly,
                            show_vertices=False,
                            show_labels=False,
                            show_dimensions=False)
            self.assertTrue(os.path.getsize(out) > 500)
        finally:
            os.unlink(out)

    def test_preview_custom_colors(self):
        """Preview con colores personalizados."""
        poly = [(100, 100), (400, 100), (400, 500), (100, 500)]
        out = temp_out()
        try:
            preview_polygon(
                self.src, out, poly,
                fill_color=(1.0, 0.5, 0.0),
                fill_opacity=0.4,
                border_color=(0.8, 0.2, 0.0),
                vertex_color=(0.0, 0.8, 0.0),
            )
            self.assertTrue(os.path.getsize(out) > 500)
        finally:
            os.unlink(out)

    def test_preview_triangle_minimal(self):
        """Preview con mínimas opciones activas."""
        poly = [(200, 100), (450, 500), (50, 500)]
        out = temp_out()
        try:
            preview_polygon(self.src, out, poly,
                            show_bounding_box=False,
                            show_dimensions=False,
                            show_labels=False)
            self.assertTrue(os.path.exists(out))
        finally:
            os.unlink(out)


class TestPreviewMultiplePolygons(unittest.TestCase):
    def setUp(self):
        self.src = make_temp_pdf()

    def tearDown(self):
        os.unlink(self.src)

    def test_two_polygons(self):
        """Dos polígonos en la misma página."""
        polys = [
            {"polygon": _regular_polygon(130, 200, 100, 5), "label": "Pentágono"},
            {"polygon": _regular_polygon(370, 400, 100, 6), "label": "Hexágono"},
        ]
        out = temp_out()
        try:
            preview_multiple_polygons(self.src, out, polys)
            self.assertTrue(os.path.getsize(out) > 1000)
        finally:
            os.unlink(out)

    def test_three_polygons_with_custom_colors(self):
        """Tres polígonos con colores explícitos."""
        polys = [
            {"polygon": [(20, 20), (200, 20), (200, 200), (20, 200)],
             "label": "Cuadrado", "color": (1.0, 0.3, 0.3), "opacity": 0.3},
            {"polygon": _regular_polygon(350, 150, 120, 3),
             "label": "Triángulo", "color": (0.3, 1.0, 0.3), "opacity": 0.3},
            {"polygon": _regular_polygon(250, 450, 130, 8),
             "label": "Octágono", "color": (0.3, 0.3, 1.0), "opacity": 0.3},
        ]
        out = temp_out()
        try:
            preview_multiple_polygons(self.src, out, polys)
            with open(out, "rb") as f:
                self.assertEqual(f.read(4), b"%PDF")
        finally:
            os.unlink(out)

    def test_polygon_with_too_few_vertices_is_skipped(self):
        """Un polígono inválido (< 3 vértices) no debe romper el resto."""
        polys = [
            {"polygon": [(0, 0), (100, 0)], "label": "Inválido"},   # < 3 vértices
            {"polygon": _regular_polygon(250, 300, 150, 5), "label": "OK"},
        ]
        out = temp_out()
        try:
            # Debe completar sin excepción
            preview_multiple_polygons(self.src, out, polys)
            self.assertTrue(os.path.exists(out))
        finally:
            os.unlink(out)

    def test_six_polygons_palette_cycle(self):
        """Seis polígonos que cubren toda la paleta de colores."""
        polys = [
            {"polygon": _regular_polygon(cx, cy, 70, n), "label": f"P{i}"}
            for i, (cx, cy, n) in enumerate([
                (85,  90,  3), (250,  90, 4), (415,  90, 5),
                (85, 290,  6), (250, 290, 7), (415, 290, 8),
            ])
        ]
        out = temp_out()
        try:
            preview_multiple_polygons(self.src, out, polys)
            self.assertGreater(os.path.getsize(out), 1000)
        finally:
            os.unlink(out)


# ─────────────────────────────────────────────────────────────────────────────
# 4. Tests de casos borde
# ─────────────────────────────────────────────────────────────────────────────

class TestEdgeCases(unittest.TestCase):
    def setUp(self):
        self.src = make_temp_pdf()

    def tearDown(self):
        os.unlink(self.src)

    def test_polygon_larger_than_page(self):
        """Polígono más grande que la página — debe clipearse al cropbox."""
        big = [(-100, -100), (W + 100, -100), (W + 100, H + 100), (-100, H + 100)]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, big)
            doc = fitz.open(out)
            page = doc[0]
            # Debe seguir siendo un PDF válido
            self.assertIsNotNone(page)
            doc.close()
        finally:
            os.unlink(out)

    def test_minimum_triangle(self):
        """Triángulo mínimo de 3 vértices."""
        tri = [(10, 10), (20, 10), (15, 20)]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, tri)
            self.assertTrue(os.path.exists(out))
        finally:
            os.unlink(out)

    def test_less_than_3_vertices_raises(self):
        """Menos de 3 vértices debe lanzar ValueError."""
        with self.assertRaises(ValueError):
            clip_to_polygon(self.src, temp_out(), [(0, 0), (1, 1)])

    def test_nonexistent_input_raises(self):
        """PDF de entrada inexistente debe lanzar excepción."""
        with self.assertRaises(Exception):
            clip_to_polygon("/no/existe.pdf", temp_out(),
                            [(0, 0), (100, 0), (50, 100)])

    def test_float_coordinates(self):
        """Coordenadas con decimales deben funcionar."""
        poly = [(12.5, 33.7), (388.2, 44.9), (200.0, 555.1)]
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, poly)
            self.assertTrue(os.path.exists(out))
        finally:
            os.unlink(out)

    def test_clockwise_polygon(self):
        """Polígono con vértices en sentido horario."""
        cw = [(20, 20), (20, 400), (480, 400), (480, 20)]  # horario
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, cw)
            self.assertTrue(os.path.exists(out))
        finally:
            os.unlink(out)


# ─────────────────────────────────────────────────────────────────────────────
# 5. Tests de polígonos con formas especiales
# ─────────────────────────────────────────────────────────────────────────────

class TestSpecialShapes(unittest.TestCase):
    def setUp(self):
        self.src = make_temp_pdf()

    def tearDown(self):
        os.unlink(self.src)

    def _run(self, poly):
        out = temp_out()
        try:
            clip_to_polygon(self.src, out, poly)
            with open(out, "rb") as f:
                return f.read(4) == b"%PDF"
        finally:
            if os.path.exists(out):
                os.unlink(out)

    def test_cross_shape(self):
        """Cruz (polígono de 12 vértices)."""
        cross = [
            (200,  20), (300,  20),
            (300, 200), (480, 200),
            (480, 300), (300, 300),
            (300, 580), (200, 580),
            (200, 300), ( 20, 300),
            ( 20, 200), (200, 200),
        ]
        self.assertTrue(self._run(cross))

    def test_arrow_shape(self):
        """Flecha apuntando a la derecha."""
        arrow = [
            ( 30, 240), (320, 240), (320, 130),
            (470, 300), (320, 470), (320, 360),
            ( 30, 360),
        ]
        self.assertTrue(self._run(arrow))

    def test_right_triangle(self):
        """Triángulo rectángulo."""
        rt = [(20, 20), (480, 580), (20, 580)]
        self.assertTrue(self._run(rt))

    def test_thin_rectangle(self):
        """Rectángulo muy delgado (banda horizontal)."""
        band = [(0, 280), (500, 280), (500, 320), (0, 320)]
        self.assertTrue(self._run(band))

    def test_octagon(self):
        """Octágono regular."""
        oct_ = _regular_polygon(250, 300, 200, 8)
        self.assertTrue(self._run(oct_))

    def test_decagon(self):
        """Decágono (10 lados)."""
        dec = _regular_polygon(250, 300, 200, 10)
        self.assertTrue(self._run(dec))

    def test_irregular_polygon(self):
        """Polígono irregular (no convexo)."""
        irreg = [
            ( 50,  80), (180,  30), (300, 100),
            (450,  60), (400, 250), (480, 400),
            (300, 550), (150, 500), ( 30, 380),
            ( 80, 200),
        ]
        self.assertTrue(self._run(irreg))


# ─────────────────────────────────────────────────────────────────────────────
# Punto de entrada para ejecución directa
# ─────────────────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    loader = unittest.TestLoader()
    suite  = unittest.TestSuite()

    for cls in [
        TestValidatePolygon,
        TestBuildClipStream,
        TestClipToPolygonIntegration,
        TestPreviewPolygon,
        TestPreviewMultiplePolygons,
        TestEdgeCases,
        TestSpecialShapes,
    ]:
        suite.addTests(loader.loadTestsFromTestCase(cls))

    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    sys.exit(0 if result.wasSuccessful() else 1)
