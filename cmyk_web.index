import cv2
import numpy as np
from sklearn.cluster import KMeans
from collections import Counter

def calcular_luminancia_relativa(color):
    """
    Calcula la luminancia relativa según WCAG 2.0
    """
    r, g, b = color / 255.0
    
    # Convertir a valores lineales
    def convertir_canal(canal):
        if canal <= 0.03928:
            return canal / 12.92
        return ((canal + 0.055) / 1.055) ** 2.4
    
    r_lin = convertir_canal(r)
    g_lin = convertir_canal(g)
    b_lin = convertir_canal(b)
    
    # Calcular luminancia relativa
    return 0.2126 * r_lin + 0.7152 * g_lin + 0.0722 * b_lin

def calcular_contraste(color1, color2):
    """
    Calcula la relación de contraste entre dos colores según WCAG
    """
    lum1 = calcular_luminancia_relativa(color1)
    lum2 = calcular_luminancia_relativa(color2)
    
    # El color más claro debe estar en el numerador
    if lum1 > lum2:
        return (lum1 + 0.05) / (lum2 + 0.05)
    return (lum2 + 0.05) / (lum1 + 0.05)

def determinar_num_colores_optimo(pixeles, rango_min=2, rango_max=10):
    """
    Determina automáticamente el número óptimo de colores usando el método del codo.
    
    Args:
        pixeles: Array de píxeles (N x 3)
        rango_min: Mínimo número de clusters a probar
        rango_max: Máximo número de clusters a probar
    
    Returns:
        Número óptimo de colores
    """
    inercias = []
    rango_k = range(rango_min, rango_max + 1)
    
    # Calcular inercia para diferentes valores de k
    for k in rango_k:
        kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
        kmeans.fit(pixeles)
        inercias.append(kmeans.inertia_)
    
    # Encontrar el "codo" calculando la segunda derivada
    if len(inercias) < 3:
        return rango_min
    
    # Calcular las diferencias
    diferencias = np.diff(inercias)
    diferencias_segunda = np.diff(diferencias)
    
    # Encontrar el punto donde la mejora se reduce significativamente
    # Usamos el punto de máxima curvatura (segunda derivada)
    if len(diferencias_segunda) > 0:
        idx_codo = np.argmax(diferencias_segunda) + 2  # +2 por los dos diff
        return min(idx_codo, rango_max)
    
    return rango_min + 2  # Valor por defecto razonable

def obtener_colores_predominantes(ruta_imagen, num_colores=None, tolerancia=20):
    """
    Identifica los colores predominantes de una imagen.
    
    Args:
        ruta_imagen: Path de la imagen a analizar
        num_colores: Número de colores predominantes a extraer. 
                     Si es None, se detecta automáticamente.
        tolerancia: Umbral de similitud para agrupar colores similares (0-255)
    
    Returns:
        Diccionario con colores predominantes y su información de contraste
    """
    # Leer la imagen
    imagen = cv2.imread(ruta_imagen)
    if imagen is None:
        raise ValueError(f"No se pudo cargar la imagen: {ruta_imagen}")
    
    # Convertir de BGR a RGB
    imagen_rgb = cv2.cvtColor(imagen, cv2.COLOR_BGR2RGB)
    
    # Redimensionar la imagen para procesamiento más rápido (opcional)
    altura, ancho = imagen_rgb.shape[:2]
    max_dimension = 800
    if max(altura, ancho) > max_dimension:
        escala = max_dimension / max(altura, ancho)
        nueva_altura = int(altura * escala)
        nuevo_ancho = int(ancho * escala)
        imagen_rgb = cv2.resize(imagen_rgb, (nuevo_ancho, nueva_altura))
    
    # Convertir la imagen a un array de píxeles
    pixeles = imagen_rgb.reshape(-1, 3)
    
    # Determinar número óptimo de colores si no se especifica
    if num_colores is None:
        print("Detectando número óptimo de colores...")
        num_colores = determinar_num_colores_optimo(pixeles, rango_min=2, rango_max=10)
        print(f"Número óptimo detectado: {num_colores} colores")
    
    # Aplicar K-means clustering
    kmeans = KMeans(n_clusters=num_colores, random_state=42, n_init=10)
    kmeans.fit(pixeles)
    
    # Obtener los colores centroides
    colores = kmeans.cluster_centers_.astype(int)
    
    # Contar cuántos píxeles pertenecen a cada cluster
    etiquetas = kmeans.labels_
    conteo = Counter(etiquetas)
    
    # Preparar los colores negro y blanco para comparación
    negro = np.array([0, 0, 0])
    blanco = np.array([255, 255, 255])
    
    # Crear el diccionario de resultados
    resultado = {}
    total_pixeles = len(pixeles)
    
    for idx, color in enumerate(colores):
        # Calcular porcentaje de presencia
        porcentaje = (conteo[idx] / total_pixeles) * 100
        
        # Calcular contraste con negro y blanco
        contraste_negro = calcular_contraste(color, negro)
        contraste_blanco = calcular_contraste(color, blanco)
        
        # Determinar mejor contraste
        mejor_contraste = "blanco" if contraste_blanco > contraste_negro else "negro"
        
        # Crear clave del color en formato RGB
        color_key = f"rgb({color[0]}, {color[1]}, {color[2]})"
        
        resultado[color_key] = {
            "rgb": tuple(color.tolist()),
            "hex": f"#{color[0]:02x}{color[1]:02x}{color[2]:02x}",
            "porcentaje": round(porcentaje, 2),
            "mejor_contraste": mejor_contraste,
            "contraste_con_negro": round(contraste_negro, 2),
            "contraste_con_blanco": round(contraste_blanco, 2)
        }
    
    # Ordenar por porcentaje (descendente)
    resultado = dict(sorted(
        resultado.items(), 
        key=lambda x: x[1]["porcentaje"], 
        reverse=True
    ))
    
    return resultado

# Ejemplo de uso
if __name__ == "__main__":
    # Ejemplo 1: Detección automática de número de colores
    try:
        print("=== Ejemplo 1: Detección automática ===")
        colores = obtener_colores_predominantes(
            "imagen.jpg",  # Cambia esto por tu ruta de imagen
            num_colores=None,  # None = detección automática
            tolerancia=20
        )
        
        print("\nColores predominantes encontrados:\n")
        for color_rgb, info in colores.items():
            print(f"Color: {color_rgb}")
            print(f"  Hex: {info['hex']}")
            print(f"  Porcentaje: {info['porcentaje']}%")
            print(f"  Mejor contraste con: {info['mejor_contraste']}")
            print(f"  Contraste con negro: {info['contraste_con_negro']}")
            print(f"  Contraste con blanco: {info['contraste_con_blanco']}")
            print()
        
        # Ejemplo 2: Especificando número de colores
        print("\n=== Ejemplo 2: 3 colores específicos ===")
        colores_3 = obtener_colores_predominantes(
            "imagen.jpg",
            num_colores=3
        )
        
        for color_rgb, info in colores_3.items():
            print(f"{color_rgb} - {info['porcentaje']}% - Contrasta con {info['mejor_contraste']}")
            
    except Exception as e:
        print(f"Error: {e}")
        print("\nAsegúrate de tener una imagen llamada 'imagen.jpg' en el directorio")
