import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from shapely.geometry import Polygon
from shapely.affinity import translate
import random

class BottomLeftPacker:
    def __init__(self, width, step_size=1.0):
        """
        Inicializa el empaquetador.
        :param width: Ancho fijo del contenedor.
        :param step_size: Resolución de la búsqueda (menor = más preciso pero más lento).
        """
        self.bin_width = width
        self.step_size = step_size
        self.placed_polygons = [] # Lista de (ID, ShapelyPolygon)
        self.positions = []       # Lista de diccionarios para el DataFrame

    def _check_valid(self, poly):
        """Verifica si el polígono está dentro del ancho y no choca con otros."""
        min_x, min_y, max_x, max_y = poly.bounds
        
        # 1. Restricción de Contenedor (Ancho fijo, Y >= 0)
        if min_x < 0 or max_x > self.bin_width or min_y < 0:
            return False
            
        # 2. Restricción de Superposición
        # Optimización: Primero checar bounding box (rápido), luego geometría exacta
        for _, other_poly in self.placed_polygons:
            if poly.intersects(other_poly):
                return False
        return True

    def place_item(self, poly_coords, item_id):
        """
        Intenta colocar un polígono usando la heurística Bottom-Left.
        """
        # Crear polígono base en el origen (0,0) relativo a su min_x, min_y
        poly = Polygon(poly_coords)
        min_x, min_y, max_x, max_y = poly.bounds
        
        # Normalizar al origen (0,0) para empezar la búsqueda
        # Movemos el polígono para que su esquina inferior izquierda esté en 0,0 localmente
        poly = translate(poly, xoff=-min_x, yoff=-min_y)
        poly_w = max_x - min_x
        poly_h = max_y - min_y

        # BÚSQUEDA GRID (Bottom-Left)
        # Iteramos Y hacia arriba (altura ilimitada)
        # Iteramos X de izquierda a derecha
        
        # Estimación de altura máxima de búsqueda para eficiencia
        # Empezamos buscando desde y=0. Incrementamos dinámicamente.
        
        search_y = 0.0
        placed = False
        
        while not placed:
            # Barrido en X (Left priority)
            for search_x in np.arange(0, self.bin_width - poly_w + self.step_size, self.step_size):
                
                # Mover polígono a la posición candidata
                candidate_poly = translate(poly, xoff=search_x, yoff=search_y)
                
                if self._check_valid(candidate_poly):
                    # ¡Encontrado!
                    self.placed_polygons.append((item_id, candidate_poly))
                    self.positions.append({
                        "ID": item_id,
                        "x": search_x,
                        "y": search_y,
                        "Area": candidate_poly.area
                    })
                    placed = True
                    break
            
            if not placed:
                search_y += self.step_size # Subir nivel

    def solve(self, polygons_list):
        """
        Ejecuta el algoritmo para una lista de polígonos.
        :param polygons_list: Lista de tuplas/listas de coordenadas.
        """
        for i, coords in enumerate(polygons_list):
            print(f"Procesando polígono ID {i+1}...")
            self.place_item(coords, i+1)
        
        # Calcular altura total utilizada
        max_h = 0
        if self.placed_polygons:
            max_h = max(p.bounds[3] for _, p in self.placed_polygons)
        return max_h

    def get_results_table(self):
        return pd.DataFrame(self.positions)

    def visualize(self, total_height):
        """Genera la visualización con Matplotlib."""
        fig, ax = plt.subplots(figsize=(8, max(6, total_height/10)))
        
        # Dibujar bordes del contenedor
        ax.set_xlim(0, self.bin_width)
        ax.set_ylim(0, total_height + 5)
        ax.plot([0, 0], [0, total_height + 5], 'k-', lw=2) # Pared izq
        ax.plot([self.bin_width, self.bin_width], [0, total_height + 5], 'k-', lw=2) # Pared der
        ax.plot([0, self.bin_width], [0, 0], 'k-', lw=2) # Piso

        # Colores aleatorios para distinción
        cmap = plt.get_cmap('tab20')
        
        for idx, (item_id, poly) in enumerate(self.placed_polygons):
            x, y = poly.exterior.xy
            color = cmap(idx % 20)
            ax.fill(x, y, alpha=0.7, fc=color, ec='black', label=f'ID {item_id}')
            
            # Etiqueta ID en el centroide
            cx, cy = poly.centroid.x, poly.centroid.y
            ax.text(cx, cy, str(item_id), fontsize=10, ha='center', va='center', color='white', weight='bold')

        # Calcular métrica de uso
        total_poly_area = sum(d['Area'] for d in self.positions)
        container_area = self.bin_width * total_height
        efficiency = (total_poly_area / container_area) * 100 if container_area > 0 else 0

        ax.set_title(f"Resultado Empaquetamiento Bottom-Left\nAltura Total: {total_height:.2f} | Eficiencia: {efficiency:.1f}%")
        ax.set_aspect('equal')
        plt.grid(True, linestyle='--', alpha=0.3)
        plt.show()

# --- DATOS DE PRUEBA (Polígonos Irregulares) ---
# Definimos algunos polígonos simples (listas de coordenadas x,y)
poligonos_input = [
    [(0,0), (4,0), (4,4), (0,4)],                # Cuadrado grande (ID 1)
    [(0,0), (3,0), (1.5, 3)],                    # Triángulo (ID 2)
    [(0,0), (2,0), (2,1), (1,1), (1,3), (0,3)],  # Forma de "L" (ID 3)
    [(0,0), (5,0), (5,2), (0,2)],                # Rectángulo largo (ID 4)
    [(0,0), (2,0), (3,2), (1,3), (-1, 2)],       # Pentágono irregular (ID 5)
    [(0,0), (3,0), (3,3)],                       # Triángulo rectángulo (ID 6)
]

# --- EJECUCIÓN ---
ANCHO_CONTENEDOR = 10
STEP_SIZE = 0.5  # Resolución de 0.5 unidades (ajustar para velocidad vs precisión)



packer = BottomLeftPacker(ANCHO_CONTENEDOR, step_size=STEP_SIZE)
altura_final = packer.solve(poligonos_input)

# 1. Mostrar Tabla
df_resultados = packer.get_results_table()
print("\n--- Tabla de Posiciones Finales ---")
print(df_resultados.to_markdown(index=False))

# 2. Visualización
packer.visualize(altura_final)
