import random
import math
import numpy as np
import matplotlib.pyplot as plt
from shapely.geometry import Polygon, Point
from shapely.affinity import rotate, translate
from copy import deepcopy

# -----------------------------
# Utilidades geométricas
# -----------------------------
def polygon_fits(poly, container, placed_polys, tolerance=0.1):
    """Chequea si poly está dentro del contenedor y no intersecta otras piezas"""
    # Verificar que esté dentro del contenedor
    if not container.contains(poly.buffer(-tolerance)):
        return False
    
    # Verificar que no intersecte con otras piezas
    for p in placed_polys:
        if poly.buffer(-tolerance).intersects(p.buffer(-tolerance)):
            return False
    return True

# -----------------------------
# Heurística Bottom-Left mejorada
# -----------------------------
def bottom_left_placement(base_poly, container, placed_polys, rotation_angle):
    """
    Estrategia Bottom-Left: busca posiciones válidas de abajo hacia arriba,
    de izquierda a derecha, con paso adaptativo
    """
    minx, miny, maxx, maxy = container.bounds
    
    # Rotar la pieza
    poly_r = rotate(base_poly, rotation_angle, origin='centroid', use_radians=False)
    bx0, by0, bx1, by1 = poly_r.bounds
    w, h = bx1 - bx0, by1 - by0
    
    # Ajustar paso según tamaño del contenedor
    step_x = min(2.0, w / 3)
    step_y = min(2.0, h / 3)
    
    best_pos = None
    best_score = float('inf')
    
    # Primero intentar posiciones clave (esquinas y bordes de piezas ya colocadas)
    candidate_points = [(minx, miny)]  # Esquina inferior izquierda
    
    for p in placed_polys:
        px0, py0, px1, py1 = p.bounds
        # Puntos alrededor de cada pieza colocada
        candidate_points.extend([
            (px1, py0),  # Derecha-abajo
            (px0, py1),  # Izquierda-arriba
            (px1, py1),  # Derecha-arriba
            (px0, py0),  # Izquierda-abajo
        ])
    
    # Probar puntos candidatos
    for cx, cy in candidate_points:
        poly_t = translate(poly_r, cx - bx0, cy - by0)
        if polygon_fits(poly_t, container, placed_polys):
            score = cy * 1000 + cx  # Priorizar abajo, luego izquierda
            if score < best_score:
                best_score = score
                best_pos = (poly_t, cx, cy)
    
    if best_pos:
        return best_pos
    
    # Si no encontró en puntos clave, hacer barrido más fino
    y = miny
    attempts = 0
    max_attempts = 500  # Límite para evitar búsquedas infinitas
    
    while y <= maxy - h and attempts < max_attempts:
        x = minx
        while x <= maxx - w and attempts < max_attempts:
            attempts += 1
            poly_t = translate(poly_r, x - bx0, y - by0)
            
            if polygon_fits(poly_t, container, placed_polys):
                score = y * 1000 + x
                if score < best_score:
                    best_score = score
                    best_pos = (poly_t, x, y)
                    return best_pos  # Retornar inmediatamente la primera posición válida
            
            x += step_x
        y += step_y
    
    return best_pos

# -----------------------------
# Evaluación de un individuo
# -----------------------------
def evaluate_individual(polys, container, order, rot_idx, rotations):
    """
    Coloca las piezas según el orden y rotaciones del individuo
    """
    placed = []
    total_area = 0.0
    
    for idx, i in enumerate(order):
        poly = polys[i]
        rotation = rotations[rot_idx[i]]
        
        res = bottom_left_placement(poly, container, placed, rotation)
        
        if res is not None:
            poly_t, x, y = res
            placed.append(poly_t)
            total_area += poly_t.area
        else:
            # Si no puede colocar esta pieza, continuar con las siguientes
            pass
    
    # Fitness: área total colocada
    num_placed = len(placed)
    fitness = total_area * 10 + num_placed * 100
    
    return placed, total_area, num_placed, fitness

# -----------------------------
# Operadores Genéticos
# -----------------------------
def random_individual(n, n_rot):
    """Crea un individuo aleatorio"""
    perm = list(range(n))
    random.shuffle(perm)
    rots = [random.randrange(n_rot) for _ in range(n)]
    return (perm, rots)

def order_crossover(p1, p2):
    """Cruce OX para permutaciones"""
    n = len(p1)
    a, b = sorted(random.sample(range(n), 2))
    
    child = [-1] * n
    child[a:b+1] = p1[a:b+1]
    
    idx = (b + 1) % n
    for i in range(n):
        gene_idx = (b + 1 + i) % n
        gene = p2[gene_idx]
        if gene not in child:
            child[idx] = gene
            idx = (idx + 1) % n
    
    return child

def mutate_swap(perm, prob=0.2):
    """Mutación por intercambio - MODIFICA in-place"""
    if random.random() < prob:
        i, j = random.sample(range(len(perm)), 2)
        perm[i], perm[j] = perm[j], perm[i]

def mutate_rotation(rots, n_rot, prob=0.25):
    """Mutación de rotaciones - MODIFICA in-place"""
    for i in range(len(rots)):
        if random.random() < prob:
            rots[i] = random.randrange(n_rot)

def tournament_selection(population, fitness, k=3):
    """Selección por torneo"""
    indices = random.sample(range(len(population)), k)
    best_idx = max(indices, key=lambda i: fitness[i])
    return population[best_idx]

# -----------------------------
# Algoritmo Genético
# -----------------------------
def genetic_packing(polys, container, rotations,
                    pop_size=40, generations=50, elite_size=4):
    """
    Algoritmo genético para packing irregular optimizado
    """
    n = len(polys)
    n_rot = len(rotations)
    
    # Población inicial
    population = [random_individual(n, n_rot) for _ in range(pop_size)]
    
    best_solution = None
    best_fitness = -float('inf')
    fitness_history = []
    
    print("Iniciando optimización...")
    print(f"Polígonos: {n}, Población: {pop_size}, Generaciones: {generations}\n")
    
    for gen in range(generations):
        # Evaluar población
        fitness_list = []
        solutions = []
        
        for ind in population:
            order, rot_idx = ind
            placed, area, num_placed, fitness = evaluate_individual(
                polys, container, order, rot_idx, rotations
            )
            
            fitness_list.append(fitness)
            solutions.append((placed, area, num_placed))
            
            if fitness > best_fitness:
                best_fitness = fitness
                best_solution = (deepcopy(ind), placed, area, num_placed)
        
        # Estadísticas
        avg_fitness = np.mean(fitness_list)
        max_fitness = max(fitness_list)
        fitness_history.append((max_fitness, avg_fitness))
        
        _, _, best_area, best_num = best_solution
        
        if (gen + 1) % 5 == 0:
            print(f"Gen {gen+1:3d}: Mejor fitness={max_fitness:7.1f}, "
                  f"Área={best_area:6.1f}, Piezas={best_num}/{n}")
        
        # Nueva población
        new_population = []
        
        # Elitismo: copiar los mejores
        elite_indices = sorted(range(len(fitness_list)), 
                              key=lambda i: fitness_list[i], 
                              reverse=True)[:elite_size]
        for idx in elite_indices:
            new_population.append(deepcopy(population[idx]))
        
        # Generar descendencia
        while len(new_population) < pop_size:
            # Selección
            parent1 = tournament_selection(population, fitness_list, k=3)
            parent2 = tournament_selection(population, fitness_list, k=3)
            
            # Crear copias para no modificar padres
            child_order = parent1[0][:]
            child_rots = parent1[1][:]
            
            # Cruce
            if random.random() < 0.85:
                child_order = order_crossover(parent1[0], parent2[0])
            
            # Cruce de rotaciones (uniforme)
            temp_rots = []
            for i in range(n):
                if random.random() < 0.5:
                    temp_rots.append(parent1[1][i])
                else:
                    temp_rots.append(parent2[1][i])
            child_rots = temp_rots
            
            # Mutación (modifica in-place)
            mutate_swap(child_order, prob=0.15)
            mutate_rotation(child_rots, n_rot, prob=0.2)
            
            new_population.append((child_order, child_rots))
        
        population = new_population
    
    print(f"\n{'='*60}")
    print(f"Optimización completada!")
    print(f"{'='*60}")
    
    return best_solution, fitness_history

# -----------------------------
# DEMO
# -----------------------------
if __name__ == "__main__":
    random.seed(123)
    np.random.seed(123)
    
    # Contenedor
    container = Polygon([(0,0), (100,0), (100,80), (0,80)])
    
    # Polígonos irregulares más simples
    polys = [
        Polygon([(0,0), (25,0), (25,20), (0,20)]),  # Rectángulo
        Polygon([(0,0), (20,0), (20,15), (0,15)]),  # Rectángulo
        Polygon([(0,0), (30,0), (25,18), (5,18)]),  # Trapezoide
        Polygon([(0,0), (22,0), (22,22), (0,22)]),  # Cuadrado
        Polygon([(0,0), (18,0), (18,25), (0,25)]),  # Rectángulo alto
        Polygon([(0,0), (28,0), (28,12), (0,12)]),  # Rectángulo ancho
        Polygon([(0,0), (15,0), (20,20), (0,15)]),  # Irregular
    ]
    
    rotations = [0, 90, 180, 270]
    
    # Ejecutar GA
    result, fit_history = genetic_packing(
        polys, container, rotations,
        pop_size=50, generations=60, elite_size=5
    )
    
    (ind, placed, area, num_placed) = result
    
    print(f"Piezas colocadas: {num_placed}/{len(polys)}")
    print(f"Área total: {area:.2f}")
    print(f"Área contenedor: {container.area:.2f}")
    print(f"Utilización: {(area/container.area)*100:.1f}%")
    print(f"{'='*60}\n")
    
    # Visualización
    fig = plt.figure(figsize=(15, 6))
    
    # Subplot 1: Resultado del packing
    ax1 = plt.subplot(1, 2, 1)
    x, y = container.exterior.xy
    ax1.plot(x, y, 'k-', linewidth=3, label='Contenedor')
    ax1.fill(x, y, alpha=0.1, color='gray')
    
    colors = plt.cm.tab10(np.linspace(0, 1, len(polys)))
    for i, p in enumerate(placed):
        px, py = p.exterior.xy
        ax1.fill(px, py, alpha=0.7, color=colors[i % len(colors)], 
                edgecolor='black', linewidth=2)
        # Etiqueta en el centro
        centroid = p.centroid
        ax1.text(centroid.x, centroid.y, str(i+1), 
                ha='center', va='center', fontweight='bold', fontsize=10)
    
    ax1.set_aspect("equal")
    ax1.set_title(f"Resultado: {num_placed}/{len(polys)} piezas | "
                  f"Área: {area:.1f} | Uso: {(area/container.area)*100:.1f}%", 
                  fontsize=13, fontweight='bold')
    ax1.grid(True, alpha=0.3, linestyle='--')
    ax1.set_xlabel('X', fontsize=11)
    ax1.set_ylabel('Y', fontsize=11)
    
    # Subplot 2: Convergencia
    ax2 = plt.subplot(1, 2, 2)
    best_fits = [f[0] for f in fit_history]
    avg_fits = [f[1] for f in fit_history]
    generations = range(1, len(fit_history) + 1)
    
    ax2.plot(generations, best_fits, 'b-', linewidth=2.5, label='Mejor', marker='o', markersize=4)
    ax2.plot(generations, avg_fits, 'r--', linewidth=2, label='Promedio', alpha=0.7)
    ax2.fill_between(generations, avg_fits, best_fits, alpha=0.2, color='blue')
    
    ax2.set_title("Convergencia del Algoritmo Genético", fontsize=13, fontweight='bold')
    ax2.set_xlabel("Generación", fontsize=11)
    ax2.set_ylabel("Fitness", fontsize=11)
    ax2.grid(True, alpha=0.3, linestyle='--')
    ax2.legend(fontsize=10, loc='lower right')
    
    plt.tight_layout()
    plt.show()
