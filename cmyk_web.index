# Ejemplo didáctico: Leftmost + GA para packing irregular con Shapely
# - Piezas: polígonos irregulares
# - Se permiten rotaciones discretas
# - Factibilidad: intersección geométrica (Shapely)
#
# NOTA: este ejemplo prioriza claridad conceptual sobre eficiencia.
# Para problemas grandes se usan NFPs, caching y estructuras espaciales.

import random
import math
import numpy as np
import matplotlib.pyplot as plt
from shapely.geometry import Polygon
from shapely.affinity import rotate, translate

# -----------------------------
# Utilidades geométricas
# -----------------------------
def polygon_fits(poly, container, placed_polys):
    """Chequea si poly está dentro del contenedor y no intersecta otras piezas"""
    if not container.contains(poly):
        return False
    for p in placed_polys:
        if poly.intersects(p):
            return False
    return True

# -----------------------------
# Heurística Leftmost (irregular)
# -----------------------------
def leftmost_place_polygon(base_poly, container, placed_polys,
                           rotations, step=1.0):
    """
    Para cada rotación:
      - rota la pieza
      - escanea posiciones (x,y) en orden leftmost
    Devuelve (poly_colocado, rot, x, y) o None
    """
    minx, miny, maxx, maxy = container.bounds
    best = None

    for angle in rotations:
        poly_r = rotate(base_poly, angle, origin=(0, 0), use_radians=False)
        bx0, by0, bx1, by1 = poly_r.bounds
        w, h = bx1 - bx0, by1 - by0

        x = minx
        while x + w <= maxx:
            y = miny
            while y + h <= maxy:
                poly_t = translate(poly_r, x - bx0, y - by0)
                if polygon_fits(poly_t, container, placed_polys):
                    if best is None or x < best[2] or (x == best[2] and y < best[3]):
                        best = (poly_t, angle, x, y)
                    break  # mínima y para este x
                y += step
            if best is not None and best[2] == minx:
                break
            x += step

    return best

# -----------------------------
# Evaluación de un individuo
# -----------------------------
def place_sequence(polys, container, order, rot_idx, rotations, step=1.0):
    placed = []
    area = 0.0

    for i in order:
        poly = polys[i]
        res = leftmost_place_polygon(
            poly,
            container,
            placed,
            [rotations[rot_idx[i]]],
            step=step
        )
        if res is not None:
            poly_t, angle, x, y = res
            placed.append(poly_t)
            area += poly_t.area

    return placed, area

# -----------------------------
# GA
# -----------------------------
def random_individual(n, n_rot):
    perm = list(range(n))
    random.shuffle(perm)
    rots = [random.randrange(n_rot) for _ in range(n)]
    return perm, rots

def order_crossover(p1, p2):
    a, b = sorted(random.sample(range(len(p1)), 2))
    c = [-1]*len(p1)
    c[a:b+1] = p1[a:b+1]
    idx = 0
    for g in p2:
        if g not in c:
            while c[idx] != -1:
                idx += 1
            c[idx] = g
    return c

def mutate_perm(p, prob=0.2):
    if random.random() < prob:
        i, j = random.sample(range(len(p)), 2)
        p[i], p[j] = p[j], p[i]

def mutate_rot(r, n_rot, prob=0.2):
    for i in range(len(r)):
        if random.random() < prob:
            r[i] = random.randrange(n_rot)

def tournament(pop, fit, k=3):
    ids = random.sample(range(len(pop)), k)
    best = max(ids, key=lambda i: fit[i])
    return pop[best]

def genetic_packing(polys, container, rotations,
                    pop_size=30, generations=60, step=1.0, elite=2):
    n = len(polys)
    pop = [random_individual(n, len(rotations)) for _ in range(pop_size)]
    best_sol = None
    best_fit = -1
    history = []

    for g in range(generations):
        fits = []
        sols = []
        for ind in pop:
            placed, area = place_sequence(
                polys, container, ind[0], ind[1], rotations, step
            )
            fits.append(area)
            sols.append((placed, area))
            if area > best_fit:
                best_fit = area
                best_sol = (ind, placed, area)
        history.append(best_fit)

        new_pop = []
        elite_ids = sorted(range(len(pop)), key=lambda i: fits[i], reverse=True)[:elite]
        for i in elite_ids:
            new_pop.append((pop[i][0][:], pop[i][1][:]))

        while len(new_pop) < pop_size:
            pA = tournament(pop, fits)
            pB = tournament(pop, fits)
            child_perm = order_crossover(pA[0], pB[0])
            child_rot = pA[1][:]
            mutate_perm(child_perm)
            mutate_rot(child_rot, len(rotations))
            new_pop.append((child_perm, child_rot))
        pop = new_pop

    return best_sol, history

# -----------------------------
# DEMO
# -----------------------------
random.seed(1)

# Contenedor
container = Polygon([(0,0), (120,0), (120,60), (0,60)])

# Polígonos irregulares
polys = [
    Polygon([(0,0),(30,0),(20,15),(0,10)]),
    Polygon([(0,0),(25,0),(25,20),(10,30),(0,20)]),
    Polygon([(0,0),(20,0),(20,10),(10,20),(0,10)]),
    Polygon([(0,0),(40,0),(30,15),(10,15)]),
    Polygon([(0,0),(15,0),(20,20),(0,15)])
]

rotations = [0, 90, 180, 270]

best, history = genetic_packing(
    polys, container, rotations,
    pop_size=25, generations=50, step=1.0
)

(ind, placed, area) = best
print(f"Área total colocada: {area:.2f}")

# Visualización
fig, ax = plt.subplots(figsize=(10,5))
x,y = container.exterior.xy
ax.plot(x,y)

for p in placed:
    x,y = p.exterior.xy
    ax.fill(x,y, alpha=0.6)

ax.set_aspect("equal")
ax.set_title("Packing irregular con Leftmost + GA (Shapely)")
plt.show()

plt.figure(figsize=(6,3))
plt.plot(history)
plt.title("Convergencia del GA")
plt.xlabel("Generación")
plt.ylabel("Mejor área")
plt.grid(True)
plt.show()
