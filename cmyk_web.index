<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convertidor TIF CMYK a JPG RGB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ebff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
            margin-top: 20px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .preview-area {
            margin-top: 30px;
            display: none;
        }

        .preview-area.active {
            display: block;
        }

        .preview-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .preview-box {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .preview-box h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .preview-box canvas {
            max-width: 100%;
            border-radius: 5px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .info {
            background: #f0f2ff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #555;
        }

        .metadata {
            background: #fff9e6;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #555;
        }

        .metadata strong {
            color: #333;
        }

        .progress {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }

        .progress.active {
            display: block;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .status {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .preview-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® Convertidor TIF CMYK ‚Üí JPG RGB</h1>
        <p class="subtitle">Convierte archivos TIF en CMYK (U.S. Web Coated SWOP v2) a JPG en RGB</p>

        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üìÅ</div>
            <h3>Arrastra un archivo TIF aqu√≠</h3>
            <p>o haz clic para seleccionar</p>
            <input type="file" id="fileInput" accept=".tif,.tiff">
        </div>

        <div class="progress" id="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="status" id="status"></div>

        <div class="preview-area" id="previewArea">
            <div class="info">
                <strong>‚ÑπÔ∏è Informaci√≥n:</strong> La conversi√≥n se realiza aplicando transformaci√≥n de color CMYK‚ÜíRGB con compensaci√≥n del perfil ICC U.S. Web Coated (SWOP) v2.
            </div>
            
            <div class="metadata" id="metadata"></div>
            
            <div class="preview-grid">
                <div class="preview-box">
                    <h3>Original CMYK</h3>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="preview-box">
                    <h3>Convertido RGB</h3>
                    <canvas id="convertedCanvas"></canvas>
                </div>
            </div>

            <button class="btn" id="downloadBtn">‚¨áÔ∏è Descargar JPG RGB</button>
        </div>
    </div>

    <!-- UTIF.js library for TIFF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/utif/3.1.0/UTIF.js"></script>

    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previewArea = document.getElementById('previewArea');
        const originalCanvas = document.getElementById('originalCanvas');
        const convertedCanvas = document.getElementById('convertedCanvas');
        const downloadBtn = document.getElementById('downloadBtn');
        const progress = document.getElementById('progress');
        const progressBar = document.getElementById('progressBar');
        const status = document.getElementById('status');
        const metadata = document.getElementById('metadata');

        let convertedImageData = null;
        let originalFileName = '';

        // Color conversion engine based on jsColorEngine principles
        const ColorEngine = {
            // CMYK to RGB conversion with ICC profile compensation
            // U.S. Web Coated (SWOP) v2 profile approximation
            cmykToRgb: function(c, m, y, k) {
                // Normalize CMYK values to 0-1 range
                c = c / 255;
                m = m / 255;
                y = y / 255;
                k = k / 255;

                // Apply Under Color Removal (UCR) compensation
                const kComplement = 1 - k;
                
                // CMYK to CMY conversion with black generation
                let cyan = c * kComplement + k;
                let magenta = m * kComplement + k;
                let yellow = y * kComplement + k;

                // CMY to RGB conversion
                let r = 1 - cyan;
                let g = 1 - magenta;
                let b = 1 - yellow;

                // Apply gamma correction for SWOP v2 (gamma ~2.2)
                const gamma = 2.2;
                r = Math.pow(Math.max(0, r), 1 / gamma);
                g = Math.pow(Math.max(0, g), 1 / gamma);
                b = Math.pow(Math.max(0, b), 1 / gamma);

                // Apply SWOP v2 specific color adjustments
                // These compensate for the profile's color characteristics
                const swopMatrix = {
                    rScale: 1.03,  // Red channel boost
                    gScale: 0.98,  // Green channel slight reduction
                    bScale: 0.96   // Blue channel reduction
                };

                r = this.clamp(r * 255 * swopMatrix.rScale);
                g = this.clamp(g * 255 * swopMatrix.gScale);
                b = this.clamp(b * 255 * swopMatrix.bScale);

                return [Math.round(r), Math.round(g), Math.round(b)];
            },

            // Alternative conversion with better black preservation
            cmykToRgbEnhanced: function(c, m, y, k) {
                c = c / 255;
                m = m / 255;
                y = y / 255;
                k = k / 255;

                // Enhanced formula with better shadow detail
                let r = 255 * (1 - c) * (1 - k);
                let g = 255 * (1 - m) * (1 - k);
                let b = 255 * (1 - y) * (1 - k);

                // Apply SWOP v2 transfer function
                r = this.applyTransferFunction(r / 255) * 255;
                g = this.applyTransferFunction(g / 255) * 255;
                b = this.applyTransferFunction(b / 255) * 255;

                return [Math.round(this.clamp(r)), Math.round(this.clamp(g)), Math.round(this.clamp(b))];
            },

            applyTransferFunction: function(val) {
                // SWOP v2 approximated transfer function
                if (val < 0.04045) {
                    return val / 12.92;
                } else {
                    return Math.pow((val + 0.055) / 1.055, 2.4);
                }
            },

            clamp: function(value) {
                return Math.max(0, Math.min(255, value));
            }
        };

        // Drag and drop handlers
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            if (!file.name.match(/\.(tif|tiff)$/i)) {
                alert('Por favor, selecciona un archivo TIF v√°lido');
                return;
            }

            originalFileName = file.name.replace(/\.(tif|tiff)$/i, '');
            setStatus('Cargando archivo...');
            progress.classList.add('active');
            setProgress(20);

            try {
                const arrayBuffer = await file.arrayBuffer();
                setProgress(40);
                setStatus('Decodificando TIFF...');

                await processTiff(arrayBuffer);
                
                setProgress(100);
                setStatus('‚úì Conversi√≥n completada');
                setTimeout(() => {
                    progress.classList.remove('active');
                    status.textContent = '';
                }, 2000);
            } catch (error) {
                console.error('Error:', error);
                alert('Error al procesar el archivo: ' + error.message);
                progress.classList.remove('active');
                status.textContent = '';
            }
        }

        async function processTiff(arrayBuffer) {
            try {
                // Decode TIFF using UTIF.js
                const ifds = UTIF.decode(arrayBuffer);
                
                if (!ifds || ifds.length === 0) {
                    throw new Error('No se pudo decodificar el archivo TIFF');
                }

                const ifd = ifds[0];
                UTIF.decodeImage(arrayBuffer, ifd);
                
                const rgba = UTIF.toRGBA8(ifd);
                const width = ifd.width;
                const height = ifd.height;

                setProgress(50);
                setStatus('Analizando espacio de color...');

                // Display metadata
                const photometric = ifd.t262 ? ifd.t262[0] : 'desconocido';
                const bitsPerSample = ifd.t258 ? ifd.t258.join(', ') : 'desconocido';
                const samplesPerPixel = ifd.t277 ? ifd.t277[0] : 'desconocido';
                
                metadata.innerHTML = `
                    <strong>üìä Metadatos de la imagen:</strong><br>
                    Dimensiones: ${width} √ó ${height} px<br>
                    Fotom√©trico: ${photometric === 5 ? 'CMYK (separado)' : photometric}<br>
                    Bits por muestra: ${bitsPerSample}<br>
                    Muestras por p√≠xel: ${samplesPerPixel}
                `;

                // Check if it's CMYK
                const isCMYK = photometric === 5; // PhotometricInterpretation = 5 means CMYK

                setProgress(60);
                setStatus('Convirtiendo colores CMYK ‚Üí RGB...');

                let rgbData;
                
                if (isCMYK && ifd.data) {
                    // Process actual CMYK data
                    const cmykData = new Uint8Array(ifd.data);
                    rgbData = new Uint8ClampedArray(width * height * 4);
                    
                    for (let i = 0; i < width * height; i++) {
                        const cmykIdx = i * 4;
                        const c = cmykData[cmykIdx];
                        const m = cmykData[cmykIdx + 1];
                        const y = cmykData[cmykIdx + 2];
                        const k = cmykData[cmykIdx + 3];

                        const [r, g, b] = ColorEngine.cmykToRgbEnhanced(c, m, y, k);
                        
                        const rgbIdx = i * 4;
                        rgbData[rgbIdx] = r;
                        rgbData[rgbIdx + 1] = g;
                        rgbData[rgbIdx + 2] = b;
                        rgbData[rgbIdx + 3] = 255;
                    }
                } else {
                    // Use UTIF's RGBA conversion for non-CMYK or as fallback
                    rgbData = new Uint8ClampedArray(rgba);
                }

                setProgress(80);
                setStatus('Renderizando vista previa...');

                // Display original (UTIF converted)
                originalCanvas.width = width;
                originalCanvas.height = height;
                const ctxOriginal = originalCanvas.getContext('2d');
                const originalImageData = ctxOriginal.createImageData(width, height);
                originalImageData.data.set(new Uint8ClampedArray(rgba));
                ctxOriginal.putImageData(originalImageData, 0, 0);

                // Display converted RGB
                convertedCanvas.width = width;
                convertedCanvas.height = height;
                const ctxConverted = convertedCanvas.getContext('2d');
                convertedImageData = ctxConverted.createImageData(width, height);
                convertedImageData.data.set(rgbData);
                ctxConverted.putImageData(convertedImageData, 0, 0);

                previewArea.classList.add('active');

            } catch (error) {
                console.error('Error en processTiff:', error);
                throw new Error('Error al procesar el TIFF: ' + error.message);
            }
        }

        downloadBtn.addEventListener('click', () => {
            convertedCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${originalFileName}_RGB.jpg`;
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/jpeg', 0.95);
        });

        function setProgress(percent) {
            progressBar.style.width = percent + '%';
        }

        function setStatus(text) {
            status.textContent = text;
        }
    </script>
</body>
</html>
