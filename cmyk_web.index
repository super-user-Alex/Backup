import numpy as np
from PIL import Image
from sklearn.cluster import KMeans
from skimage import color
import colorsys

class ColorAnalyzer:
    def __init__(self, image_path, num_clusters=5):
        """
        Initializes the analyzer.
        :param image_path: Path to the input image.
        :param num_clusters: The number of colors to group pixels into (k in K-Means).
        """
        self.image_path = image_path
        self.num_clusters = num_clusters
        self.img_rgb = None
        self.results = []

    def load_and_preprocess(self):
        """
        Loads the image, resizes for performance, and converts to LAB space.
        """
        try:
            with Image.open(self.image_path) as img:
                img = img.convert('RGB')
                # Resize to speed up processing (K-Means is slow on large images)
                # 128x128 provides enough data for color dominance without the overhead
                img.thumbnail((128, 128))
                self.img_rgb = np.array(img)
        except FileNotFoundError:
            raise FileNotFoundError(f"Could not find image at {self.image_path}")

    def get_contrast_color(self, rgb):
        """
        Determines the best contrast color (Black or White) based on luminance.
        Uses the standard luminance formula: L = 0.299R + 0.587G + 0.114B
        """
        r, g, b = rgb
        # Calculate luminance (0 to 255 scale)
        luminance = (0.299 * r + 0.587 * g + 0.114 * b)
        
        # If dark, return White; if bright, return Black
        return (255, 255, 255) if luminance < 128 else (0, 0, 0)

    def get_complementary_color(self, rgb):
        """
        Calculates the complementary color by shifting Hue by 180 degrees.
        """
        r, g, b = [x / 255.0 for x in rgb] # Normalize to 0-1
        h, l, s = colorsys.rgb_to_hls(r, g, b)
        
        # Shift hue by 0.5 (180 degrees)
        h = (h + 0.5) % 1.0
        
        new_r, new_g, new_b = colorsys.hls_to_rgb(h, l, s)
        return (int(new_r * 255), int(new_g * 255), int(new_b * 255))

    def analyze(self):
        """
        Performs the K-Means clustering in LAB space and calculates metrics.
        """
        self.load_and_preprocess()

        # 1. Convert to LAB Space for perceptually uniform clustering
        # Normalize to 0-1 for skimage conversion
        img_normalized = self.img_rgb / 255.0
        img_lab = color.rgb2lab(img_normalized)
        
        # Flatten the image into a list of pixels for the clustering algorithm
        w, h, d = img_lab.shape
        pixel_array_lab = img_lab.reshape((w * h, d))

        # 2. Perform K-Means Clustering
        clt = KMeans(n_clusters=self.num_clusters, random_state=42, n_init=10)
        labels = clt.fit_predict(pixel_array_lab)
        
        # 3. Count labels to get percentages
        label_counts = np.bincount(labels)
        total_count = len(labels)
        
        # 4. Process each cluster center
        centers_lab = clt.cluster_centers_
        
        # Reshape to 1xNx3 for conversion back to RGB
        centers_lab_reshaped = centers_lab.reshape((1, self.num_clusters, 3))
        centers_rgb = color.lab2rgb(centers_lab_reshaped)[0] * 255

        # Sort results by percentage (most dominant first)
        sorted_indices = np.argsort(label_counts)[::-1]

        print(f"--- Analysis for: {self.image_path} ---")
        print(f"{'Predominant (RGB)':<25} {'Percentage':<12} {'Contrast (RGB)':<20} {'Complementary (RGB)':<20}")
        print("-" * 80)

        for i in sorted_indices:
            # Main Color
            rgb_raw = centers_rgb[i]
            predominant_rgb = tuple(map(int, rgb_raw))
            
            # Percentage
            percentage = (label_counts[i] / total_count) * 100
            
            # Contrast
            contrast_rgb = self.get_contrast_color(predominant_rgb)
            contrast_name = "White" if contrast_rgb == (255, 255, 255) else "Black"
            
            # Complementary
            comp_rgb = self.get_complementary_color(predominant_rgb)
            
            # Store structured data
            self.results.append({
                "predominant": predominant_rgb,
                "percentage": round(percentage, 2),
                "contrast": contrast_rgb,
                "complementary": comp_rgb
            })

            print(f"{str(predominant_rgb):<25} {percentage:>6.2f}%      {str(contrast_rgb) + ' (' + contrast_name + ')':<20} {str(comp_rgb):<20}")

        return self.results

# --- Usage Example ---
if __name__ == "__main__":
    # Ensure you have an image named 'test_image.jpg' in the directory
    # or change this path to your specific file.
    # Create a dummy image for demonstration if file doesn't exist
    
    import os
    
    input_image = "input.jpg"
    
    # If image doesn't exist, create a gradient image for testing
    if not os.path.exists(input_image):
        print("Image not found. Creating a test gradient image...")
        w, h = 512, 512
        arr = np.zeros((h, w, 3), dtype=np.uint8)
        for y in range(h):
            for x in range(w):
                # Simple gradient: Blue to Pink
                arr[y, x] = [x % 255, 0, y % 255]
        img = Image.fromarray(arr)
        img.save(input_image)
        print(f"Created {input_image}")

    analyzer = ColorAnalyzer(input_image, num_clusters=5)
    data = analyzer.analyze()
