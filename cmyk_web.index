import random
import numpy as np
from collections import deque
from concurrent.futures import ProcessPoolExecutor
from copy import deepcopy


# ============================================================================
# CLASE INDIVIDUAL (sin cambios)
# ============================================================================

class Individual:
    """Representa una soluci√≥n al problema de packing"""
    
    def __init__(self, n_items, allowed_angles):
        self.indices = list(range(n_items))
        self.angles = [random.choice(allowed_angles) for _ in range(n_items)]
        self.fitness = float('inf')
        self.is_valid = False
        self.allowed_angles = allowed_angles
        self.age = 0
    
    def copy(self):
        new_ind = Individual(len(self.indices), self.allowed_angles)
        new_ind.indices = self.indices.copy()
        new_ind.angles = self.angles.copy()
        new_ind.fitness = self.fitness
        new_ind.is_valid = self.is_valid
        new_ind.age = self.age
        return new_ind
    
    def get_signature(self):
        return (tuple(self.indices), tuple(self.angles))


# ============================================================================
# OPERADORES DE MUTACI√ìN CORREGIDOS
# ============================================================================

def mutate_indices_aggressive(indices, mutation_rate=0.2, force_change=False):
    """
    Mutaci√≥n m√°s agresiva para √≠ndices.
    CORREGIDO: maneja casos con n_items peque√±os (‚â§3).
    """
    indices = indices.copy()
    n = len(indices)
    
    # Caso especial: muy pocos items
    if n <= 1:
        return indices
    
    if n == 2:
        # Solo puede hacer swap
        if force_change or random.random() < mutation_rate:
            indices[0], indices[1] = indices[1], indices[0]
        return indices
    
    # n >= 3: comportamiento normal
    if force_change or random.random() < mutation_rate:
        intensity = random.random()
        
        if intensity < 0.4:  # Mutaci√≥n suave
            operator = 'swap'
        elif intensity < 0.7:  # Mutaci√≥n media
            operator = 'inversion'
        else:  # Mutaci√≥n fuerte
            operator = 'scramble'
        
        if operator == 'swap':
            # M√∫ltiples swaps
            n_swaps = random.randint(1, max(1, n // 10))
            for _ in range(n_swaps):
                i, j = random.sample(range(n), 2)
                indices[i], indices[j] = indices[j], indices[i]
                
        elif operator == 'inversion':
            # Inversi√≥n de segmento
            # CORREGIDO: asegurar que length sea v√°lido
            max_length = max(2, n // 3)
            length = random.randint(2, min(max_length, n))
            
            if length < n:
                i = random.randint(0, n - length)
                indices[i:i+length] = reversed(indices[i:i+length])
            else:
                # Si length >= n, invertir todo
                indices.reverse()
            
        elif operator == 'scramble':
            # Scramble de segmento
            # CORREGIDO: asegurar que length sea v√°lido
            max_length = max(3, n // 2)
            length = random.randint(3, min(max_length, n))
            
            if length < n:
                # CORREGIDO: asegurar que i sea v√°lido
                max_i = max(0, n - length)
                i = random.randint(0, max_i) if max_i > 0 else 0
                segment = indices[i:i+length]
                random.shuffle(segment)
                indices[i:i+length] = segment
            else:
                # Si length >= n, mezclar todo
                random.shuffle(indices)
    
    return indices


def mutate_angles_aggressive(angles, allowed_angles, mutation_rate=0.3, force_change=False):
    """
    Mutaci√≥n m√°s agresiva para √°ngulos.
    Sin cambios necesarios - ya maneja bien todos los casos.
    """
    angles = angles.copy()
    changed = False
    
    for i in range(len(angles)):
        should_mutate = force_change and not changed
        should_mutate = should_mutate or random.random() < mutation_rate
        
        if should_mutate:
            if random.random() < 0.5:
                new_angle = random.choice(allowed_angles)
                while force_change and new_angle == angles[i] and len(allowed_angles) > 1:
                    new_angle = random.choice(allowed_angles)
                angles[i] = new_angle
            else:
                current_idx = allowed_angles.index(angles[i])
                delta = random.choice([-1, 1])
                new_idx = (current_idx + delta) % len(allowed_angles)
                angles[i] = allowed_angles[new_idx]
            
            changed = True
    
    return angles


# ============================================================================
# MEDICI√ìN DE DIVERSIDAD
# ============================================================================

def calculate_population_diversity(population):
    """
    Calcula la diversidad de la poblaci√≥n.
    Retorna el porcentaje de individuos √∫nicos.
    """
    unique_signatures = set()
    
    for ind in population:
        unique_signatures.add(ind.get_signature())
    
    diversity = len(unique_signatures) / len(population) if population else 0
    return diversity, len(unique_signatures)


def hamming_distance_indices(ind1, ind2):
    """Distancia de Hamming entre dos permutaciones"""
    if len(ind1.indices) == 0:
        return 0
    distance = sum(1 for i, j in zip(ind1.indices, ind2.indices) if i != j)
    return distance / len(ind1.indices)


def hamming_distance_angles(ind1, ind2):
    """Distancia de Hamming entre dos vectores de √°ngulos"""
    if len(ind1.angles) == 0:
        return 0
    distance = sum(1 for a1, a2 in zip(ind1.angles, ind2.angles) if a1 != a2)
    return distance / len(ind1.angles)


def population_diversity_metric(population):
    """
    Calcula diversidad promedio entre todos los pares.
    """
    if len(population) < 2:
        return 1.0
    
    total_distance = 0
    comparisons = 0
    
    sample_size = min(50, len(population))
    sample = random.sample(population, sample_size)
    
    for i in range(len(sample)):
        for j in range(i + 1, len(sample)):
            dist_indices = hamming_distance_indices(sample[i], sample[j])
            dist_angles = hamming_distance_angles(sample[i], sample[j])
            total_distance += (dist_indices + dist_angles) / 2
            comparisons += 1
    
    return total_distance / comparisons if comparisons > 0 else 0.0


# ============================================================================
# INYECCI√ìN DE DIVERSIDAD Y ELIMINACI√ìN DE DUPLICADOS
# ============================================================================

def inject_diversity(population, n_items, allowed_angles, injection_rate=0.2):
    """
    Reemplaza parte de la poblaci√≥n con individuos nuevos aleatorios.
    """
    n_inject = int(len(population) * injection_rate)
    
    if n_inject == 0:
        return population
    
    population.sort(key=lambda x: x.fitness)
    
    for i in range(len(population) - n_inject, len(population)):
        new_ind = Individual(n_items, allowed_angles)
        random.shuffle(new_ind.indices)
        new_ind.angles = [random.choice(allowed_angles) for _ in range(n_items)]
        population[i] = new_ind
    
    return population


def remove_duplicates(population, n_items, allowed_angles):
    """
    Elimina individuos duplicados de la poblaci√≥n.
    """
    seen_signatures = set()
    unique_population = []
    duplicates = []
    
    for ind in population:
        sig = ind.get_signature()
        if sig not in seen_signatures:
            seen_signatures.add(sig)
            unique_population.append(ind)
        else:
            duplicates.append(ind)
    
    for dup in duplicates:
        if random.random() < 0.7:
            new_ind = dup.copy()
            new_ind.indices = mutate_indices_aggressive(
                new_ind.indices, 
                mutation_rate=1.0, 
                force_change=True
            )
            new_ind.angles = mutate_angles_aggressive(
                new_ind.angles, 
                allowed_angles,
                mutation_rate=1.0,
                force_change=True
            )
            new_ind.fitness = float('inf')
            unique_population.append(new_ind)
        else:
            new_ind = Individual(n_items, allowed_angles)
            random.shuffle(new_ind.indices)
            new_ind.angles = [random.choice(allowed_angles) for _ in range(n_items)]
            unique_population.append(new_ind)
    
    return unique_population


# ============================================================================
# CROSSOVER
# ============================================================================

def crossover(parent1, parent2, crossover_rate=0.8):
    """
    Crossover especializado con manejo de casos peque√±os.
    """
    if random.random() > crossover_rate:
        return parent1.copy(), parent2.copy()
    
    n = len(parent1.indices)
    allowed_angles = parent1.allowed_angles
    
    # Caso especial: n muy peque√±o
    if n <= 2:
        # Para n peque√±o, solo hacer crossover de √°ngulos
        child1 = parent1.copy()
        child2 = parent2.copy()
        
        child1.angles = [random.choice([a1, a2]) for a1, a2 in zip(parent1.angles, parent2.angles)]
        child2.angles = [random.choice([a1, a2]) for a1, a2 in zip(parent2.angles, parent1.angles)]
        
        return child1, child2
    
    # n >= 3: Order Crossover normal
    def order_crossover(p1_indices, p2_indices):
        cx_point1, cx_point2 = sorted(random.sample(range(n), 2))
        
        child = [None] * n
        child[cx_point1:cx_point2] = p1_indices[cx_point1:cx_point2]
        
        p2_filtered = [item for item in p2_indices if item not in child]
        
        idx = 0
        for i in range(n):
            if child[i] is None:
                child[i] = p2_filtered[idx]
                idx += 1
        
        return child
    
    child1_indices = order_crossover(parent1.indices, parent2.indices)
    child2_indices = order_crossover(parent2.indices, parent1.indices)
    
    def angle_crossover(p1_angles, p2_angles):
        return [random.choice([a1, a2]) for a1, a2 in zip(p1_angles, p2_angles)]
    
    child1_angles = angle_crossover(parent1.angles, parent2.angles)
    child2_angles = angle_crossover(parent2.angles, parent1.angles)
    
    child1 = Individual(n, allowed_angles)
    child1.indices = child1_indices
    child1.angles = child1_angles
    
    child2 = Individual(n, allowed_angles)
    child2.indices = child2_indices
    child2.angles = child2_angles
    
    return child1, child2


# ============================================================================
# EVALUACI√ìN
# ============================================================================

def evaluate_individual(individual, place_func, fitness_func):
    """
    Eval√∫a un individuo y maneja casos inv√°lidos.
    CORREGIDO: convierte a numpy arrays para fitness_func.
    """
    try:
        placement_result = place_func(individual.indices, individual.angles)
        
        if placement_result is None:
            individual.fitness = 1e10
            individual.is_valid = False
        else:
            # Convertir a numpy arrays para la funci√≥n fitness
            indices_array = np.array(individual.indices)
            angles_array = np.array(individual.angles)
            
            individual.fitness = fitness_func(indices_array, angles_array)
            individual.is_valid = True
            
    except Exception as e:
        individual.fitness = 1e10
        individual.is_valid = False
        # Opcional: descomentar para debug
        # print(f"Error evaluando individuo: {e}")
    
    return individual


# ============================================================================
# INICIALIZACI√ìN
# ============================================================================

def initialize_population(pop_size, n_items, allowed_angles):
    """Inicializaci√≥n b√°sica"""
    population = []
    for _ in range(pop_size):
        ind = Individual(n_items, allowed_angles)
        random.shuffle(ind.indices)
        ind.angles = [random.choice(allowed_angles) for _ in range(n_items)]
        population.append(ind)
    return population


def initialize_population_with_heuristics(pop_size, n_items, allowed_angles, 
                                         item_sizes=None, n_heuristic=10):
    """Inicializaci√≥n con heur√≠sticas"""
    population = []
    
    if item_sizes is not None and n_heuristic > 0:
        heuristics = [
            sorted(range(n_items), key=lambda i: -item_sizes[i]),
            sorted(range(n_items), key=lambda i: item_sizes[i]),
            list(range(n_items)),
        ]
        
        for h in heuristics[:n_heuristic]:
            ind = Individual(n_items, allowed_angles)
            ind.indices = h.copy()
            ind.angles = [allowed_angles[0]] * n_items
            population.append(ind)
            if len(population) >= n_heuristic:
                break
    
    while len(population) < pop_size:
        ind = Individual(n_items, allowed_angles)
        random.shuffle(ind.indices)
        ind.angles = [random.choice(allowed_angles) for _ in range(n_items)]
        population.append(ind)
    
    return population


# ============================================================================
# SELECCI√ìN
# ============================================================================

def tournament_selection(population, tournament_size=5, n_parents=50):
    """Selecci√≥n por torneo"""
    parents = []
    for _ in range(n_parents):
        tournament = random.sample(population, min(tournament_size, len(population)))
        winner = min(tournament, key=lambda x: x.fitness)
        parents.append(winner.copy())
    return parents


# ============================================================================
# B√öSQUEDA LOCAL
# ============================================================================

def local_search(individual, place_func, fitness_func, max_iterations=20):
    """
    B√∫squeda local con manejo robusto de casos peque√±os.
    """
    best = individual.copy()
    best_fitness = individual.fitness
    n = len(individual.indices)
    
    # Caso especial: muy pocos items
    if n <= 1:
        return best
    
    for _ in range(max_iterations):
        neighbor = best.copy()
        
        if random.random() < 0.5 or n == 2:
            # Cambiar un √°ngulo
            idx = random.randint(0, len(neighbor.angles) - 1)
            neighbor.angles[idx] = random.choice(neighbor.allowed_angles)
        else:
            # Swap de dos √≠ndices
            if n >= 2:
                i, j = random.sample(range(n), 2)
                neighbor.indices[i], neighbor.indices[j] = neighbor.indices[j], neighbor.indices[i]
        
        evaluate_individual(neighbor, place_func, fitness_func)
        
        if neighbor.fitness < best_fitness:
            best = neighbor.copy()
            best_fitness = neighbor.fitness
    
    return best


# ============================================================================
# UTILIDADES
# ============================================================================

def create_fitness_cache(fitness_func):
    """Crea cach√© para fitness"""
    cache = {}
    
    def cached_fitness(indices, angles):
        key = (tuple(indices.tolist() if hasattr(indices, 'tolist') else indices), 
               tuple(angles.tolist() if hasattr(angles, 'tolist') else angles))
        
        if key not in cache:
            cache[key] = fitness_func(indices, angles)
            cached_fitness.cache_misses += 1
        else:
            cached_fitness.cache_hits += 1
        return cache[key]
    
    cached_fitness.cache = cache
    cached_fitness.cache_hits = 0
    cached_fitness.cache_misses = 0
    
    return cached_fitness


def adaptive_mutation_rate(generation, max_generations, initial_rate=0.3, min_rate=0.05):
    """Tasa de mutaci√≥n adaptativa"""
    decay = generation / max_generations
    return initial_rate * (1 - decay) + min_rate


# ============================================================================
# ALGORITMO GEN√âTICO PRINCIPAL
# ============================================================================

def genetic_algorithm_packing_diverse(
    n_items,
    allowed_angles,
    place_func,
    fitness_func,
    population_size=100,
    n_generations=500,
    elite_size=10,
    mutation_rate_indices=0.3,
    mutation_rate_angles=0.4,
    crossover_rate=0.8,
    tournament_size=5,
    early_stopping_patience=50,
    local_search_frequency=10,
    local_search_iterations=20,
    diversity_threshold=0.3,
    diversity_check_frequency=5,
    injection_rate=0.2,
    adaptive_mutation=True,
    verbose=True,
    item_sizes=None,
    use_cache=True
):
    """
    Algoritmo Gen√©tico con control de diversidad.
    CORREGIDO: maneja casos con n_items peque√±os.
    """
    
    # Validaci√≥n de par√°metros
    if n_items < 1:
        raise ValueError("n_items debe ser al menos 1")
    
    if len(allowed_angles) < 1:
        raise ValueError("allowed_angles debe tener al menos un √°ngulo")
    
    # Ajustar par√°metros para n_items peque√±os
    if n_items <= 3:
        population_size = min(population_size, 20)
        elite_size = min(elite_size, max(1, population_size // 5))
        if verbose:
            print(f"‚ö† n_items={n_items} es peque√±o. Ajustando poblaci√≥n a {population_size}")
    
    # Configuraci√≥n de cach√©
    if use_cache:
        fitness_func = create_fitness_cache(fitness_func)
    
    # Inicializaci√≥n
    if verbose:
        print(f"Inicializando poblaci√≥n de {population_size} individuos...")
    
    if item_sizes is not None:
        population = initialize_population_with_heuristics(
            population_size, n_items, allowed_angles, item_sizes, 
            n_heuristic=min(10, population_size // 10)
        )
    else:
        population = initialize_population(population_size, n_items, allowed_angles)
    
    # Evaluar poblaci√≥n inicial
    if verbose:
        print("Evaluando poblaci√≥n inicial...")
    
    for ind in population:
        evaluate_individual(ind, place_func, fitness_func)
    
    # Tracking
    best_fitness_history = deque(maxlen=early_stopping_patience)
    global_best = min(population, key=lambda x: x.fitness)
    generation_best_fitness = []
    diversity_history = []
    
    if verbose:
        diversity, n_unique = calculate_population_diversity(population)
        print(f"Fitness inicial mejor: {global_best.fitness:.6f}")
        print(f"Diversidad inicial: {diversity*100:.1f}% ({n_unique} √∫nicos)")
        print(f"\nIniciando evoluci√≥n por {n_generations} generaciones...")
        print("=" * 70)
    
    # Ciclo evolutivo
    for generation in range(n_generations):
        
        # Incrementar edad
        for ind in population:
            ind.age += 1
        
        # Chequeo de diversidad
        if generation % diversity_check_frequency == 0:
            diversity, n_unique = calculate_population_diversity(population)
            diversity_metric = population_diversity_metric(population)
            diversity_history.append(diversity)
            
            if verbose and generation % 20 == 0:
                print(f"Gen {generation:4d}: Diversidad={diversity*100:.1f}% "
                      f"({n_unique} √∫nicos), M√©trica={diversity_metric:.3f}")
            
            # Inyecci√≥n de diversidad
            if diversity < diversity_threshold:
                if verbose:
                    print(f"Gen {generation:4d}: ‚ö† Diversidad baja, inyectando individuos...")
                
                population = inject_diversity(
                    population, n_items, allowed_angles, injection_rate
                )
                
                for ind in population:
                    if ind.fitness == float('inf'):
                        evaluate_individual(ind, place_func, fitness_func)
        
        # Remover duplicados
        if generation % (diversity_check_frequency * 2) == 0:
            population = remove_duplicates(population, n_items, allowed_angles)
            
            for ind in population:
                if ind.fitness == float('inf'):
                    evaluate_individual(ind, place_func, fitness_func)
        
        # Mutaci√≥n adaptativa
        if adaptive_mutation:
            current_mutation_indices = adaptive_mutation_rate(
                generation, n_generations, 
                initial_rate=mutation_rate_indices,
                min_rate=0.1
            )
            current_mutation_angles = adaptive_mutation_rate(
                generation, n_generations,
                initial_rate=mutation_rate_angles,
                min_rate=0.15
            )
        else:
            current_mutation_indices = mutation_rate_indices
            current_mutation_angles = mutation_rate_angles
        
        # Selecci√≥n
        n_offspring = population_size - elite_size
        parents = tournament_selection(
            population, 
            tournament_size=tournament_size, 
            n_parents=n_offspring
        )
        
        # Elitismo
        population.sort(key=lambda x: x.fitness)
        elite = [ind.copy() for ind in population[:elite_size]]
        
        # Crossover
        offspring = []
        for i in range(0, len(parents), 2):
            if i + 1 < len(parents):
                child1, child2 = crossover(
                    parents[i], 
                    parents[i+1], 
                    crossover_rate
                )
                offspring.extend([child1, child2])
            else:
                offspring.append(parents[i].copy())
        
        # Mutaci√≥n
        for child in offspring:
            child.indices = mutate_indices_aggressive(
                child.indices, 
                current_mutation_indices
            )
            child.angles = mutate_angles_aggressive(
                child.angles, 
                allowed_angles,
                current_mutation_angles
            )
        
        # Evaluaci√≥n
        for child in offspring:
            evaluate_individual(child, place_func, fitness_func)
        
        # Reemplazo
        population = elite + offspring[:population_size - elite_size]
        
        # Actualizar mejor
        current_best = min(population, key=lambda x: x.fitness)
        generation_best_fitness.append(current_best.fitness)
        
        if current_best.fitness < global_best.fitness:
            global_best = current_best.copy()
            if verbose:
                print(f"Gen {generation:4d}: ‚òÖ NUEVA MEJOR = {global_best.fitness:.6f}")
        
        # B√∫squeda local
        if generation > 0 and generation % local_search_frequency == 0:
            improved_best = local_search(
                global_best, 
                place_func, 
                fitness_func,
                max_iterations=local_search_iterations
            )
            
            if improved_best.fitness < global_best.fitness:
                global_best = improved_best.copy()
                if verbose:
                    print(f"Gen {generation:4d}: ‚úì B√∫squeda local ‚Üí {global_best.fitness:.6f}")
        
        # Early stopping
        best_fitness_history.append(current_best.fitness)
        
        if len(best_fitness_history) == early_stopping_patience:
            fitness_range = max(best_fitness_history) - min(best_fitness_history)
            recent_diversity = sum(diversity_history[-10:]) / len(diversity_history[-10:]) if len(diversity_history) >= 10 else diversity
            
            if fitness_range < 1e-6 and recent_diversity < 0.4:
                if verbose:
                    print(f"\n{'='*70}")
                    print(f"Convergencia en generaci√≥n {generation}")
                    print(f"Diversidad final: {recent_diversity*100:.1f}%")
                break
        
        # Logging
        if verbose and generation % 50 == 0 and generation > 0:
            avg_fitness = sum(ind.fitness for ind in population) / len(population)
            valid_count = sum(1 for ind in population if ind.is_valid)
            print(f"Gen {generation:4d}: Mejor={current_best.fitness:.6f}, "
                  f"Promedio={avg_fitness:.6f}, V√°lidos={valid_count}/{population_size}")
    
    # B√∫squeda local final
    if verbose:
        print(f"\n{'='*70}")
        print("B√∫squeda local final intensiva...")
    
    final_best = local_search(
        global_best, 
        place_func, 
        fitness_func,
        max_iterations=local_search_iterations * 3
    )
    
    if final_best.fitness < global_best.fitness:
        global_best = final_best.copy()
        if verbose:
            print(f"‚úì Mejora final ‚Üí {global_best.fitness:.6f}")
    
    # Estad√≠sticas finales
    if verbose:
        print(f"\n{'='*70}")
        print("RESULTADOS FINALES:")
        print(f"{'='*70}")
        print(f"Mejor fitness: {global_best.fitness:.6f}")
        print(f"Soluci√≥n v√°lida: {global_best.is_valid}")
        print(f"Generaciones: {generation + 1}")
        
        if use_cache:
            total_evals = fitness_func.cache_hits + fitness_func.cache_misses
            if total_evals > 0:
                print(f"\nEstad√≠sticas de cach√©:")
                print(f"  Evaluaciones totales: {total_evals}")
                print(f"  Soluciones √∫nicas: {len(fitness_func.cache)}")
                print(f"  Cache hits: {fitness_func.cache_hits} ({fitness_func.cache_hits/total_evals*100:.1f}%)")
                print(f"  Eficiencia: {100 - len(fitness_func.cache)/total_evals*100:.1f}% evaluaciones ahorradas")
        
        print(f"{'='*70}")
    
    return global_best, generation_best_fitness, diversity_history


# ============================================================================
# VERSI√ìN COMPLETA CON AN√ÅLISIS DETALLADO
# ============================================================================

if __name__ == "__main__":
    
    def example_place_func(indices, angles):
        """Funci√≥n de colocaci√≥n - siempre v√°lida para pruebas"""
        return True
    
    def example_fitness_func(indices, angles):
        """
        Funci√≥n fitness de prueba que busca:
        - indices en orden inverso: [n-1, n-2, ..., 1, 0]
        - angles alternando 90 y 180
        """
        n = len(indices)
        indices_ideal = np.array(list(range(n))[::-1])
        angles_ideal = np.array([90 if i % 2 == 0 else 180 for i in range(n)])
        
        dist = np.linalg.norm(indices - indices_ideal) + np.linalg.norm(angles - angles_ideal)
        return dist
    
    # Almacenar resultados de todas las pruebas
    all_results = []
    
    # Probar con diferentes tama√±os
    test_sizes = [2, 3, 5, 10, 15]
    
    for n_items in test_sizes:
        print("\n" + "="*70)
        print(f"PRUEBA CON n_items = {n_items}")
        print("="*70)
        
        optimal_indices = list(range(n_items))[::-1]
        optimal_angles = [90 if i % 2 == 0 else 180 for i in range(n_items)]
        
        print(f"Objetivo:")
        print(f"  Indices: {optimal_indices}")
        print(f"  √Ångulos: {optimal_angles}")
        print("="*70 + "\n")
        
        allowed_angles = [0, 90, 180, 270]
        
        # Configuraci√≥n adaptativa seg√∫n tama√±o
        if n_items <= 3:
            pop_size, n_gen = 20, 100
        elif n_items <= 5:
            pop_size, n_gen = 40, 150
        elif n_items <= 10:
            pop_size, n_gen = 60, 200
        else:
            pop_size, n_gen = 80, 300
        
        import time
        start_time = time.time()
        
        best, fitness_hist, diversity_hist = genetic_algorithm_packing_diverse(
            n_items=n_items,
            allowed_angles=allowed_angles,
            place_func=example_place_func,
            fitness_func=example_fitness_func,
            population_size=pop_size,
            n_generations=n_gen,
            elite_size=max(2, pop_size // 10),
            mutation_rate_indices=0.5,
            mutation_rate_angles=0.6,
            crossover_rate=0.8,
            tournament_size=3,
            early_stopping_patience=40,
            local_search_frequency=10,
            local_search_iterations=15,
            diversity_threshold=0.3,
            diversity_check_frequency=5,
            injection_rate=0.25,
            adaptive_mutation=True,
            verbose=True,
            use_cache=True
        )
        
        elapsed_time = time.time() - start_time
        
        # ====================================================================
        # AN√ÅLISIS DETALLADO DE LA SOLUCI√ìN
        # ====================================================================
        
        print(f"\n{'='*70}")
        print(f"RESULTADO DETALLADO PARA n_items={n_items}")
        print(f"{'='*70}")
        
        # Informaci√≥n b√°sica
        print(f"\nüìä M√©tricas Generales:")
        print(f"  Fitness final: {best.fitness:.6f}")
        print(f"  Tiempo de ejecuci√≥n: {elapsed_time:.2f} segundos")
        print(f"  Generaciones ejecutadas: {len(fitness_hist)}")
        
        # Comparaci√≥n con objetivo
        print(f"\nüéØ Comparaci√≥n con Objetivo:")
        print(f"  Indices obtenidos: {best.indices}")
        print(f"  Indices esperados:  {optimal_indices}")
        print(f"  √Ångulos obtenidos: {best.angles}")
        print(f"  √Ångulos esperados:  {optimal_angles}")
        
        # Calcular distancias
        indices_array = np.array(best.indices)
        angles_array = np.array(best.angles)
        optimal_indices_array = np.array(optimal_indices)
        optimal_angles_array = np.array(optimal_angles)
        
        index_distance = np.linalg.norm(indices_array - optimal_indices_array)
        angle_distance = np.linalg.norm(angles_array - optimal_angles_array)
        
        is_optimal_indices = (best.indices == optimal_indices)
        is_optimal_angles = (best.angles == optimal_angles)
        
        # An√°lisis de precisi√≥n
        print(f"\nüìè An√°lisis de Distancias:")
        print(f"  Distancia total: {best.fitness:.6f}")
        print(f"  Distancia en indices: {index_distance:.6f} ({index_distance/best.fitness*100:.1f}% del total)")
        print(f"  Distancia en √°ngulos: {angle_distance:.6f} ({angle_distance/best.fitness*100:.1f}% del total)")
        
        # Contar elementos correctos
        correct_indices = sum(1 for a, b in zip(best.indices, optimal_indices) if a == b)
        correct_angles = sum(1 for a, b in zip(best.angles, optimal_angles) if a == b)
        
        print(f"\n‚úì Elementos Correctos:")
        print(f"  Indices correctos: {correct_indices}/{n_items} ({correct_indices/n_items*100:.1f}%)")
        print(f"  √Ångulos correctos: {correct_angles}/{n_items} ({correct_angles/n_items*100:.1f}%)")
        
        # Determinar calidad de la soluci√≥n
        print(f"\nüèÜ Evaluaci√≥n de Calidad:")
        
        if is_optimal_indices and is_optimal_angles:
            quality = "√ìPTIMA"
            icon = "ü•á"
            print(f"  {icon} SOLUCI√ìN {quality}!")
            print(f"  ‚úì‚úì‚úì Ambos componentes (indices y √°ngulos) son perfectos! ‚úì‚úì‚úì")
            
        elif best.fitness < 0.01:
            quality = "CASI √ìPTIMA"
            icon = "ü•à"
            print(f"  {icon} SOLUCI√ìN {quality}")
            print(f"  ‚úì‚úì Extremadamente cercana al √≥ptimo (fitness < 0.01)")
            if is_optimal_indices:
                print(f"  ‚úì Indices perfectos")
                print(f"  ‚Üí √Ångulos con {n_items - correct_angles} errores m√≠nimos")
            elif is_optimal_angles:
                print(f"  ‚úì √Ångulos perfectos")
                print(f"  ‚Üí Indices con {n_items - correct_indices} errores m√≠nimos")
            else:
                print(f"  ‚Üí Ambos componentes casi perfectos")
                
        elif best.fitness < 1.0:
            quality = "EXCELENTE"
            icon = "ü•â"
            print(f"  {icon} SOLUCI√ìN {quality}")
            print(f"  ‚úì Muy cercana al √≥ptimo (fitness < 1.0)")
            if is_optimal_indices:
                print(f"  ‚úì Indices perfectos")
            elif is_optimal_angles:
                print(f"  ‚úì √Ångulos perfectos")
            print(f"  ‚Üí Precisi√≥n en indices: {correct_indices/n_items*100:.1f}%")
            print(f"  ‚Üí Precisi√≥n en √°ngulos: {correct_angles/n_items*100:.1f}%")
            
        elif best.fitness < 5.0:
            quality = "BUENA"
            icon = "üëç"
            print(f"  {icon} SOLUCI√ìN {quality}")
            print(f"  ‚Üí Aceptable pero mejorable (fitness < 5.0)")
            print(f"  ‚Üí Precisi√≥n en indices: {correct_indices/n_items*100:.1f}%")
            print(f"  ‚Üí Precisi√≥n en √°ngulos: {correct_angles/n_items*100:.1f}%")
            
        elif best.fitness < 10.0:
            quality = "REGULAR"
            icon = "‚Üí"
            print(f"  {icon} SOLUCI√ìN {quality}")
            print(f"  ‚Üí Distante del √≥ptimo (5.0 ‚â§ fitness < 10.0)")
            print(f"  ‚Üí Precisi√≥n en indices: {correct_indices/n_items*100:.1f}%")
            print(f"  ‚Üí Precisi√≥n en √°ngulos: {correct_angles/n_items*100:.1f}%")
            
        else:
            quality = "INSUFICIENTE"
            icon = "‚ö†"
            print(f"  {icon} SOLUCI√ìN {quality}")
            print(f"  ‚ö† Muy distante del √≥ptimo (fitness ‚â• 10.0)")
            print(f"  ‚Üí Precisi√≥n en indices: {correct_indices/n_items*100:.1f}%")
            print(f"  ‚Üí Precisi√≥n en √°ngulos: {correct_angles/n_items*100:.1f}%")
        
        # An√°lisis de convergencia
        if len(fitness_hist) > 10:
            initial_fitness = fitness_hist[0]
            final_fitness = fitness_hist[-1]
            improvement = ((initial_fitness - final_fitness) / initial_fitness * 100) if initial_fitness > 0 else 0
            
            print(f"\nüìà An√°lisis de Convergencia:")
            print(f"  Fitness inicial: {initial_fitness:.6f}")
            print(f"  Fitness final: {final_fitness:.6f}")
            print(f"  Mejora total: {improvement:.2f}%")
            
            # Detectar en qu√© generaci√≥n encontr√≥ el mejor
            best_gen = fitness_hist.index(min(fitness_hist))
            print(f"  Mejor soluci√≥n en gen: {best_gen}/{len(fitness_hist)} ({best_gen/len(fitness_hist)*100:.1f}%)")
        
        print(f"{'='*70}")
        
        # Guardar resultados para resumen final
        all_results.append({
            'n_items': n_items,
            'fitness': best.fitness,
            'time': elapsed_time,
            'generations': len(fitness_hist),
            'quality': quality,
            'correct_indices': correct_indices,
            'correct_angles': correct_angles,
            'is_optimal': is_optimal_indices and is_optimal_angles,
            'fitness_history': fitness_hist,
            'diversity_history': diversity_hist
        })
    
    # ========================================================================
    # RESUMEN FINAL DE TODAS LAS PRUEBAS
    # ========================================================================
    
    print("\n" + "="*70)
    print("üìä RESUMEN GENERAL DE TODAS LAS PRUEBAS")
    print("="*70)
    
    print(f"\n{'n_items':<10} {'Fitness':<12} {'Calidad':<15} {'Tiempo':<10} {'Gens':<8} {'√ìptima':<8}")
    print("-" * 70)
    
    for result in all_results:
        optimal_mark = "‚úì" if result['is_optimal'] else "‚úó"
        print(f"{result['n_items']:<10} {result['fitness']:<12.6f} {result['quality']:<15} "
              f"{result['time']:<10.2f} {result['generations']:<8} {optimal_mark:<8}")
    
    # Estad√≠sticas agregadas
    print("\n" + "="*70)
    print("üìà ESTAD√çSTICAS AGREGADAS")
    print("="*70)
    
    optimal_count = sum(1 for r in all_results if r['is_optimal'])
    excellent_count = sum(1 for r in all_results if r['fitness'] < 1.0)
    avg_time = sum(r['time'] for r in all_results) / len(all_results)
    avg_fitness = sum(r['fitness'] for r in all_results) / len(all_results)
    
    print(f"\n  Soluciones √≥ptimas encontradas: {optimal_count}/{len(all_results)} ({optimal_count/len(all_results)*100:.1f}%)")
    print(f"  Soluciones excelentes (fitness<1): {excellent_count}/{len(all_results)} ({excellent_count/len(all_results)*100:.1f}%)")
    print(f"  Tiempo promedio de ejecuci√≥n: {avg_time:.2f} segundos")
    print(f"  Fitness promedio: {avg_fitness:.6f}")
    
    print("\n" + "="*70)
    
    # ========================================================================
    # VISUALIZACI√ìN
    # ========================================================================
    
    try:
        import matplotlib.pyplot as plt
        
        print("\nüé® Generando visualizaciones...")
        
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # 1. Evoluci√≥n del fitness para cada tama√±o
        ax1 = axes[0, 0]
        for result in all_results:
            ax1.plot(result['fitness_history'], 
                    label=f"n={result['n_items']}", 
                    linewidth=2)
        ax1.set_xlabel('Generaci√≥n', fontsize=12)
        ax1.set_ylabel('Mejor Fitness', fontsize=12)
        ax1.set_title('Evoluci√≥n del Fitness por Tama√±o de Problema', 
                     fontsize=14, fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        ax1.set_yscale('log')
        
        # 2. Fitness final vs n_items
        ax2 = axes[0, 1]
        n_items_list = [r['n_items'] for r in all_results]
        fitness_list = [r['fitness'] for r in all_results]
        colors = ['green' if r['is_optimal'] else 'orange' if r['fitness'] < 1.0 else 'red' 
                 for r in all_results]
        ax2.scatter(n_items_list, fitness_list, c=colors, s=200, alpha=0.6)
        ax2.plot(n_items_list, fitness_list, 'b--', alpha=0.3)
        ax2.set_xlabel('N√∫mero de Items', fontsize=12)
        ax2.set_ylabel('Fitness Final', fontsize=12)
        ax2.set_title('Fitness Final vs Tama√±o del Problema', 
                     fontsize=14, fontweight='bold')
        ax2.grid(True, alpha=0.3)
        
        # Leyenda de colores
        from matplotlib.patches import Patch
        legend_elements = [
            Patch(facecolor='green', alpha=0.6, label='√ìptima'),
            Patch(facecolor='orange', alpha=0.6, label='Excelente (< 1.0)'),
            Patch(facecolor='red', alpha=0.6, label='Mejorable')
        ]
        ax2.legend(handles=legend_elements, loc='upper left')
        
        # 3. Tiempo de ejecuci√≥n vs n_items
        ax3 = axes[1, 0]
        time_list = [r['time'] for r in all_results]
        ax3.bar(n_items_list, time_list, color='steelblue', alpha=0.7)
        ax3.set_xlabel('N√∫mero de Items', fontsize=12)
        ax3.set_ylabel('Tiempo (segundos)', fontsize=12)
        ax3.set_title('Tiempo de Ejecuci√≥n vs Tama√±o del Problema', 
                     fontsize=14, fontweight='bold')
        ax3.grid(True, alpha=0.3, axis='y')
        
        # Agregar valores encima de las barras
        for i, (n, t) in enumerate(zip(n_items_list, time_list)):
            ax3.text(n, t, f'{t:.2f}s', ha='center', va='bottom', fontsize=9)
        
        # 4. Diversidad promedio (si est√° disponible)
        ax4 = axes[1, 1]
        for result in all_results:
            if result['diversity_history']:
                ax4.plot(result['diversity_history'], 
                        label=f"n={result['n_items']}", 
                        linewidth=2)
        ax4.set_xlabel('Chequeo de Diversidad', fontsize=12)
        ax4.set_ylabel('Diversidad', fontsize=12)
        ax4.set_title('Evoluci√≥n de la Diversidad', 
                     fontsize=14, fontweight='bold')
        ax4.axhline(y=0.3, color='red', linestyle='--', 
                   label='Umbral m√≠nimo', linewidth=2)
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('complete_analysis.png', dpi=300, bbox_inches='tight')
        print("‚úì Visualizaci√≥n guardada en 'complete_analysis.png'")
        
    except ImportError:
        print("\n(matplotlib no disponible para visualizaci√≥n)")
    except Exception as e:
        print(f"\n(Error generando visualizaci√≥n: {e})")
    
    print("\n" + "="*70)
    print("üéâ AN√ÅLISIS COMPLETO FINALIZADO")
    print("="*70 + "\n")
