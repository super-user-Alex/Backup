import cv2
import numpy as np
import matplotlib.pyplot as plt

def crear_forma_simple(centro, tamaño, rotacion=0):
    """Crea una forma simple (rectángulo) con rotación"""
    puntos = np.array([
        [-1, -0.5],
        [1, -0.5],
        [1, 0.5],
        [-1, 0.5]
    ]) * tamaño
    
    # Aplicar rotación
    angulo_rad = np.radians(rotacion)
    matriz_rot = np.array([
        [np.cos(angulo_rad), -np.sin(angulo_rad)],
        [np.sin(angulo_rad), np.cos(angulo_rad)]
    ])
    puntos_rot = puntos @ matriz_rot.T
    
    # Trasladar al centro
    puntos_rot += centro
    
    return puntos_rot.astype(np.int32)

def obtener_descriptores_fourier_completos(contorno, num_descriptores=20):
    """
    Calcula los descriptores de Fourier manteniendo información de fase
    para poder calcular el ángulo de rotación
    """
    # Obtener coordenadas complejas del contorno
    contorno = contorno.squeeze()
    coords_complejas = contorno[:, 0] + 1j * contorno[:, 1]
    
    # Calcular transformada de Fourier
    fourier_result = np.fft.fft(coords_complejas)
    
    # Tomar los primeros coeficientes
    descriptores = fourier_result[:num_descriptores]
    
    return descriptores

def calcular_angulo_rotacion(desc_A, desc_B):
    """
    Calcula el ángulo que hay que rotar B para alinearlo con A
    usando la fase del primer coeficiente significativo de Fourier
    """
    # Usamos el coeficiente de índice 1 (el primero después del DC)
    # La diferencia de fase nos da la rotación
    
    fase_A = np.angle(desc_A[1])
    fase_B = np.angle(desc_B[1])
    
    # Diferencia de fase
    diff_fase = fase_A - fase_B
    
    # Convertir a grados
    angulo = np.degrees(diff_fase)
    
    # Normalizar al rango [-180, 180]
    angulo = ((angulo + 180) % 360) - 180
    
    return angulo

def comparar_magnitudes(desc1, desc2, num_coef=10):
    """Compara solo las magnitudes para verificar si son la misma forma"""
    mag1 = np.abs(desc1[1:num_coef+1])
    mag2 = np.abs(desc2[1:num_coef+1])
    
    # Normalizar
    if mag1[0] > 1e-10:
        mag1 = mag1 / mag1[0]
    if mag2[0] > 1e-10:
        mag2 = mag2 / mag2[0]
    
    distancia = np.linalg.norm(mag1 - mag2)
    return distancia

# Crear imagen en blanco
img_size = 400
centro = (img_size // 2, img_size // 2)

# Crear formas con diferentes rotaciones conocidas
rotaciones_reales = [0, 30, 75, 120, -45]
descriptores_lista = []
imagenes = []

print("=" * 70)
print("CÁLCULO DE ÁNGULO DE ROTACIÓN USANDO DESCRIPTORES DE FOURIER")
print("=" * 70)

# Objeto A (referencia) con rotación 0°
img_A = np.zeros((img_size, img_size), dtype=np.uint8)
forma_A = crear_forma_simple(centro, 60, 0)
cv2.fillPoly(img_A, [forma_A], 255)
contornos_A, _ = cv2.findContours(img_A, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
desc_A = obtener_descriptores_fourier_completos(contornos_A[0], num_descriptores=20)

print(f"\nObjeto A (referencia): Rotación = 0°")
print("-" * 70)

# Crear y analizar objetos B con diferentes rotaciones
for idx, rot in enumerate(rotaciones_reales):
    img_B = np.zeros((img_size, img_size), dtype=np.uint8)
    forma_B = crear_forma_simple(centro, 60, rot)
    cv2.fillPoly(img_B, [forma_B], 255)
    
    contornos_B, _ = cv2.findContours(img_B, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    desc_B = obtener_descriptores_fourier_completos(contornos_B[0], num_descriptores=20)
    
    # Calcular ángulo de rotación
    angulo_calculado = calcular_angulo_rotacion(desc_A, desc_B)
    
    # Verificar si son la misma forma
    distancia_mag = comparar_magnitudes(desc_A, desc_B)
    
    # Calcular error
    error = abs(angulo_calculado - rot)
    if error > 180:
        error = 360 - error
    
    print(f"\nObjeto B_{idx+1}:")
    print(f"  Rotación real:      {rot:7.2f}°")
    print(f"  Rotación calculada: {angulo_calculado:7.2f}°")
    print(f"  Error:              {error:7.2f}°")
    print(f"  Distancia magnitudes: {distancia_mag:.6f} (similar si < 0.01)")
    
    descriptores_lista.append(desc_B)
    imagenes.append(img_B)

# Visualización
fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# Mostrar objeto A
axes[0, 0].imshow(img_A, cmap='gray')
axes[0, 0].set_title('Objeto A\n(Referencia: 0°)', fontweight='bold')
axes[0, 0].axis('off')

# Mostrar algunos objetos B
for idx in range(min(5, len(imagenes))):
    row = (idx + 1) // 3
    col = (idx + 1) % 3
    
    if row < 2 and col < 3:
        angulo_calc = calcular_angulo_rotacion(desc_A, descriptores_lista[idx])
        axes[row, col].imshow(imagenes[idx], cmap='gray')
        axes[row, col].set_title(
            f'Objeto B_{idx+1}\nReal: {rotaciones_reales[idx]}° | '
            f'Calculado: {angulo_calc:.1f}°',
            fontsize=10
        )
        axes[row, col].axis('off')

plt.tight_layout()
plt.savefig('calculo_angulo_rotacion.png', dpi=150, bbox_inches='tight')
plt.show()

# Ejemplo con forma diferente
print("\n" + "=" * 70)
print("PRUEBA CON FORMA DIFERENTE (Triángulo)")
print("=" * 70)

img_triangulo = np.zeros((img_size, img_size), dtype=np.uint8)
triangulo = np.array([
    [centro[0], centro[1] - 60],
    [centro[0] - 50, centro[1] + 40],
    [centro[0] + 50, centro[1] + 40]
], dtype=np.int32)
cv2.fillPoly(img_triangulo, [triangulo], 255)

contornos_tri, _ = cv2.findContours(img_triangulo, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
desc_triangulo = obtener_descriptores_fourier_completos(contornos_tri[0], num_descriptores=20)

angulo_tri = calcular_angulo_rotacion(desc_A, desc_triangulo)
distancia_tri = comparar_magnitudes(desc_A, desc_triangulo)

print(f"\nComparación Rectángulo vs Triángulo:")
print(f"  Ángulo calculado: {angulo_tri:.2f}° (no es significativo)")
print(f"  Distancia magnitudes: {distancia_tri:.6f}")
print(f"  → Son formas DIFERENTES (distancia alta)")

print("\n" + "=" * 70)
print("CONCLUSIÓN:")
print("  - El ángulo de rotación se calcula con la FASE del coeficiente Fourier")
print("  - Las MAGNITUDES determinan si son la misma forma")
print("  - Permite tanto reconocer formas como encontrar su orientación")
print("=" * 70)
